// Mouse.cpp : implementation file
//


#include "stdafx.h" 

#include "drgraf.h"
#include "drgrafrm.h"
#include "UserMsg.h"
#include "drawView.h"
/////////////////////
#include "drgradoc.h"
#include "ObjMgr.h"
#include "NewObjs.h"
#include "DListMgr.h"
/////////////////////
#include "Def_Objs.h"                    
#include "Def_Mous.h"                    
#include "Def_CuPS.h"                    
#include "Def_Ms.h" // Mesh Types for Patch
///////////////////// dialogMgr
#include "MNodMgr.h"  
///////////////////// elements
#include "Def_IGen.h"
#include "Def_Elem.h"
#include "Ext_Elem.h"
#include "DrNode.h"
#include "DrCurve.h"
#include "DrPatch.h"
#include "DrObj3D.h"
///////////////////// DrawObjs
#include "Def_Draw.h"
#include "DrLabel.h" 	
///////////////////// specials
#include "Def_Spec.h"
#include "Obj3DMnu.h"
#include "PatchMnu.h"
#include "DrPen.h"
#include "Layer.h"
#include "booleans.h"
#include "precison.h"
/////////////////////
#include "mouse.h"
#include "DListMgr.h"
/////////////////////
#include "MI_GangP.h" 
#include "MI_PSPN.h" 
////////////////////// 
#include "Dlg_PatI.h"
//////////////////////
#include "PatMouse.h" 

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
//////////////////////////////////////////////
#define MAX_INFO_XLATE		3	// 1 Curves/2 Nodes        
#define MAX_INFO_ROTATE		3	// 1 Curves/2 Nodes           
#define MAX_INFO_LOFT2		2	// 2 Curves           
#define MAX_INFO_DUCT		4	// 3 Curves/1 Node        
#define MAX_INFO_SWEEP		5	// 4 Curves/1 Node    
#define MAX_INFO_COONS		4	// 3 or 4 Curves  
///////      
#define MIN_CURVES_PATCH	3        
#define	new					DEBUG_NEW
#define	BUFF_SIZE			1024
#define MAX_NODES_FE2D		4
////////////////////////////////////
IMPLEMENT_SERIAL(CPatMouse,CCurMouse,1)
/////////////////////////////////////////////////////////////////////////////
CPatMouse::CPatMouse()
{

	////////////////////////////
	m_pPatInDlg			= NULL;                                                                                
 	/////////////////////////////////////////// Patch 
	m_nInfoDone			= 0;
	m_nCurveDone		= 0;
	m_nNodeDone			= 0;
    m_LastPatchNum		= 0;		// internal
	m_PatProc			= PP_LOFT4;
	m_PatSubType		= PS_QUADRILAT;
	m_CurrentPatchID	= "P0";
	m_bPatchDone		= TRUE;		// for dragging

/*	
	for(int i=0;i<4;i++)
	{
		m_PatCurveID[i]			= "";
		m_PatCurveLatch[i]	= CL_FORWARD;
		m_PatCurveElem[i]		= 0;
	}
*/
	if(!m_LatchList.IsEmpty())
		m_LatchList.RemoveAll();
	if(!m_ElSegList.IsEmpty())
		m_ElSegList.RemoveAll();
	if(!m_NodeList.IsEmpty())
		m_NodeList.RemoveAll();
	if(!m_CurveList.IsEmpty())
		m_CurveList.RemoveAll();
	/////////////////////////////
	m_PatProc			= PP_COONS;
	m_SegAngle			= 120.;
	m_bAutoSeg			= TRUE;
	m_dAngSpec			= 0.;
	m_dLen				= 1.;
	m_FromID			= "";
	m_ToID				= "";
	///
	m_bTwist			= TRUE;// Twist or Radius
	m_bIncrement		= FALSE;
	m_TwistStart		= 0.0;
	m_RadiusMult		= 0.0;
	m_bIncRad			= FALSE;
	m_RadStart			= 0.0;
	m_TwistMult			= 0.0;
	m_dLen				= 1.0;
	///////////////////////////////////////////// 
}

CPatMouse::~CPatMouse()
{
	/////////////////////////////////// Modeless Dialogs
	if(m_pPatInDlg->m_hWnd)
		m_pPatInDlg->DestroyWindow();
	///////////////////
	delete m_pPatInDlg; 
	///////////////////
}

void CPatMouse::InitDlgIn_PAT()
{
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////////////// System Sizes
	m_pPatInDlg		= new CDlg_PatI(pWnd,m_PatProc); 
}
	
int CPatMouse::LeftDown_PATCH()
{
	return 0;
}
	
void CPatMouse:: ElementLeftDown_PAT()
{	
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CBooleans* pBool		= (CBooleans*)pObjectMgr->GetSpecObject(BOOLEANS);
	/////////////////////////////////////////////////////////
//	int nMeshType;
	////////////////////////
	m_bPatchDone	= FALSE;
	/////////////////////
	switch(m_nActiveTool) 
	{
		
		////////////////////////////////////////////////// PATCH
		case P_COONS:

			m_PatProc = PP_COONS;
			LeftDown_PATCH();
			return;

		case P_EXTRUDE:				// 

			m_PatProc = PP_EXTRUDE;
			LeftDown_PATCH();
			return;

		case P_ROTATE: 

			m_PatProc = PP_ROTATE;
			LeftDown_PATCH();
			return;

		case P_LOFT: 

			m_PatProc = PP_LOFT2;
			LeftDown_PATCH();
			return;

		case P_DUCT: 

			m_PatProc = PP_DUCT;
			m_bTwist  = TRUE;
			LeftDown_PATCH();
			return;

		case P_SWEEP: 

			m_PatProc = PP_SWEEP;
			m_bTwist  = TRUE;
			if(m_nCurveDone == 3)
				m_bTwist  = FALSE;
			LeftDown_PATCH();
			return;

		////////////////////////////////////////////////// SPAWN	
		case P_SPAWN:				// PATCH

			m_PatProc = PP_SPAWN;
			LeftDown_PATCH();
			return;

		////////////////////////////////////////////////// STITCH	
		case P_STITCH:				// PATCH
			///////		
			m_PatProc = PP_STITCH;
			LeftDown_PATCH();
			return;
/*
		////////////////////////////////////////////////// POST	
		case P_POST:				// PATCH 
			///////		
			m_MI_Pat_P.LBDownInit_PPost();
			return;
*/		
		//////////////////////////////////////////////////
		default:
			break;
	}  

}

void CPatMouse::OnEBoxLButtonDown_PAT(CClientDC* pdc,CView* pView,GENERATE gener,
											UINT nFlags, CPoint point)
{
	m_nFlags				= nFlags;
	m_pView					= pView;
	m_pdc					= pdc;
	////////////////////////////////
	m_Gener					= gener;
	/////////////////////////////////////////////////////////
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CBooleans* pBool		= (CBooleans*)pObjectMgr->GetSpecObject(BOOLEANS);
	CDListMgr* pDListMgr;
	/////////////////////////////////// 
   	m_bDragOn 		= pBool->IsDragOn();
	m_bDialogOn		= pBool->IsDialogOn();
	m_bAutoAcceptOn	= pBool->IsAutoAcceptOn();
	m_bSingleSegOn	= pBool->IsSingleSegOn();
	m_bBLineOn		= pBool->IsBLineOn();
	if(m_bPatchDone)			// Reset
	{
		m_nInfoDone		= 0;
		m_nNodeDone		= 0;
		m_nCurveDone	= 0;
		////////////////////
		if(!m_NodeList.IsEmpty())
			m_NodeList.RemoveAll();
		if(!m_ElSegList.IsEmpty())
			m_ElSegList.RemoveAll();
		if(!m_LatchList.IsEmpty())
			m_LatchList.RemoveAll();
		if(!m_CurveList.IsEmpty())
			m_CurveList.RemoveAll();
	}
	//////////////////////////////////////////////////////// LOG
	m_pdc->DPtoLP(&point);
	//////////////////////////////////////////////////
	m_nActiveObject = pWnd->GetActiveObjectType(); 
	m_nActiveTool	= pWnd->GetActiveToolType();    // -1= INSERT
	/////////////////////////////////////////////////////////////////////////
	pObjectMgr->SetActiveObjectType(m_nActiveObject);       // Set ObjectType 
	////////////////////////////////////////////////// take care of Edit AllClear
	pDListMgr 	= pObjectMgr->GetObjectList(NODE);
	if(!(pDListMgr->GetSpecificObjectCount(NODE)) ) m_nNodeDone = 0;
	/////////////////////////////////////////////////////////////////
    /////////////////////////////  ELement Dialog On/Off Check
    if(m_Gener == FORWARD)
		ElementLeftDown_PAT();
	else	
    if(m_Gener == REVERSE)
		;
//		ElementLeftDown_I();
	//////////////////////////////////
}

void CPatMouse::UpdatePDlg_TRUE()
{
	//////////////////////////////////
	m_pPatInDlg->UpdateData(TRUE); // from screen
	//////////////////////////////
//	m_PatProc			= GetPatInDlg()->m_PatProc;
	m_CurrentPatchID	= GetPatInDlg()->m_PID;
	m_CurrentCurveID	= GetPatInDlg()->m_CID;
	m_CurrentNodeID		= GetPatInDlg()->m_NID;
	m_ThirdCoord		= GetPatInDlg()->m_dCoord;
	m_ElPerSeg			= GetPatInDlg()->m_nMesh;
	m_Ratio				= GetPatInDlg()->m_Ratio;
	m_Orient			= GetPatInDlg()->m_Orient;
	m_bClosed			= GetPatInDlg()->m_bClosed;
	m_dLen				= GetPatInDlg()->m_dLen;
	////
	m_bTwist			= GetPatInDlg()->m_bTwist;
	if(m_bTwist)
	{
		m_bIncrement		= GetPatInDlg()->m_bIncrement;
		m_TwistStart		= GetPatInDlg()->m_TwistStart;
		m_TwistMult			= GetPatInDlg()->m_TwistMult;
	}
	else
	{
		m_bIncRad			= GetPatInDlg()->m_bIncrement;
		m_RadStart			= GetPatInDlg()->m_TwistStart;
		m_RadiusMult		= GetPatInDlg()->m_TwistMult;
	}
	////
	m_SegAngle			= GetPatInDlg()->m_SegAngle;
	m_bAutoSeg			= GetPatInDlg()->m_bAutoSeg;
	///////////////////////////////////////////////////// List Inclusion, If Any
	switch(m_PatProc)
	{
		case PP_EXTRUDE:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				default:
					break;
			}
			break;

		case PP_ROTATE:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				default:
					break;
			}
			break;

		case PP_LOFT2:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				default:
					break;
			}
			break;

		case PP_COONS:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				case 3:
					break;
				default:
					break;
			}
			break;

		case PP_DUCT:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				default:
					break;
			}
			break;
		case PP_SWEEP:
			switch(m_nInfoDone)
			{
				case 0:
					break;
				case 1:
					break;
				case 2:
					break;
				case 3:
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}
}			

void CPatMouse::UpdatePDlg_FALSE()
{
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	CString strCurr;
	//////////////////////////////////////
	if(m_nInfoDone>=1)
		m_pPatInDlg->GetDlgItem(IDC_PID)->EnableWindow(FALSE);
	//////////////////////////////
	GetPatInDlg()->m_PatProc	= m_PatProc;
	GetPatInDlg()->m_PID		= m_CurrentPatchID;
	GetPatInDlg()->m_CID		= m_CurrentCurveID;
	GetPatInDlg()->m_NID		= "";
	GetPatInDlg()->m_dCoord		= m_ThirdCoord;
	GetPatInDlg()->m_nMesh		= m_ElPerSeg;
	GetPatInDlg()->m_Ratio		= m_Ratio;
//	GetPatInDlg()->m_Orient		= m_Orient;
	/////
	GetPatInDlg()->m_bClosed	= m_bClosed;
	if(m_bClosed)
		m_dLen = 360.;
	GetPatInDlg()->m_dLen		= m_dLen;
	/////
	GetPatInDlg()->m_bTwist		= m_bTwist;
	if(m_bTwist)
	{
		GetPatInDlg()->m_bIncrement	= m_bIncrement;
		GetPatInDlg()->m_TwistStart	= m_TwistStart;
		GetPatInDlg()->m_TwistMult	= m_TwistMult;
	}
	else
	{
		GetPatInDlg()->m_bIncrement	= m_bIncRad;
		GetPatInDlg()->m_TwistStart	= m_RadStart;
		GetPatInDlg()->m_TwistMult	= m_RadiusMult;
	}
	/////
	GetPatInDlg()->m_SegAngle	= m_SegAngle;
	GetPatInDlg()->m_bAutoSeg	= m_bAutoSeg;
	///////////////////////////////
	switch(m_PatProc)
	{
		case PP_EXTRUDE:

			switch(m_nInfoDone)
			{
				case 0:
					strCurr = "Patch by Extrusion: Click in@A Curve To Extrude";
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Extrn. Curve");
					if(m_Orient == "FORWARD")
 						((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
					else
					if(m_Orient == "BACKWARD")
 						((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
					break;
				case 1:
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Extrusion: Click in@Ist (C)Node defining Extrusion Direction";
					GetPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Dirn. Node From");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 2:
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Extrusion: Click in@2nd (C)Node defining Extrusion Direction";
					GetPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Dirn. Node To");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 3:
					strCurr = "Ready with other Info.?@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_NID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;


		case PP_ROTATE:

			switch(m_nInfoDone)
			{
				case 0:
					strCurr = "Patch by Rotation: Click in@A Curve To Rotate";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Rotnl. Curve");
					if(m_Orient == "FORWARD")
 						((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
					else
					if(m_Orient == "BACKWARD")
 						((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
					break;
				case 1:
					//////
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Rotation: Click in@Ist (C)Node defining Rotation Axis";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Axis Node From");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 2:
					//////
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Rotation: Click in@2nd (C)Node defining Rotation Axis";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Axis Node To");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 3:
					strCurr = "Ready with other Info.?@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_NID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;


		case PP_LOFT2:

			if(m_Orient == "FORWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
			else
			if(m_Orient == "BACKWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
			///////////////////
			switch(m_nInfoDone)
			{
				case 0:
					strCurr = "Patch by Lofting: Click in@A Curve To Loft From";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Begin Curve");
					break;
				case 1:
					strCurr = "Patch by Lofting: Click in@A Curve To Loft To";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("End Curve");
					break;
				case 2:
					strCurr = "Ready with other Info.?@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;


		case PP_COONS:

			if(m_Orient == "FORWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
			else
			if(m_Orient == "BACKWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
			///////////////////
			switch(m_nInfoDone)
			{
				case 0:
					strCurr = "Patch by Coons Method:@Click in The First Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Ist Curve");
					break;
				case 1:
					strCurr = "Patch by Coons Method:@Click in The 2nd Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("2nd Curve");
					break;
				case 2:
					strCurr += "Patch by Coons Method:@Click in The 3rd Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("3rd Curve");
					break;
				case 3:
					strCurr = "Quadrilateral: Select Last Curve@ Triangle: Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Last Curve");
					break;
				case 4:
					strCurr = "Quadrilateral Patch:@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;

		case PP_DUCT:

			if(m_Orient == "FORWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
			else
			if(m_Orient == "BACKWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
			///////////////////
			switch(m_nInfoDone)
			{
				case 0:
					strCurr = "Patch by Ducting:@Click in Cross Sectional Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Xsec. CurveID");
					break;
				case 1:
					strCurr = "Patch by Ducting:@Click in Spine Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Spine CurveID");
					break;
				case 2:
					strCurr = "Patch by Ducting:@Click in Twist Distribution Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Twist CurveID");
					break;
				case 3:
					//////
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Ducting:@Click in Anchor Node";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Anchor Node");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 4:
					strCurr = "Ready with other Info.?@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_NID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;

			
			case PP_SWEEP:

			if(m_Orient == "FORWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
			else
			if(m_Orient == "BACKWARD")
 				((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
			///////////////////
			switch(m_nInfoDone)
			{
				case 0:
					strCurr += "Patch by Sweeping:@Click in Cross Sectional Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Xsec. Curve");
					break;
				case 1:
					strCurr += "Patch by Sweeping:@Click in Spine Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Spine Curve");
					break;
				case 2:
					strCurr = "Patch by Sweeping:@Click in Twist Distribution Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Twist Curve");
					break;
				case 3:
					strCurr = "Patch by Sweeping:@Click in Radial Distribution Curve";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("Radius Curve");
					break;
				case 4:
					//////
					GetPatInDlg()->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					GetPatInDlg()->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					//////
					GetPatInDlg()->GetDlgItem(IDC_OTHER)->SetWindowText("Z");
					GetPatInDlg()->GetDlgItem(IDC_COORD)->EnableWindow(TRUE);
					//////
					strCurr = "Patch by Sweeping:@Click in Anchor Node";
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("Anchor Node");
					GetPatInDlg()->GetDlgItem(IDC_NID)->EnableWindow(TRUE);
					break;
				case 5:
					strCurr = "Ready with other Info.?@Click Right Button";
					m_pPatInDlg->GetDlgItem(IDC_CIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_CID)->EnableWindow(FALSE);
					m_pPatInDlg->GetDlgItem(IDC_NIDHEAD)->SetWindowText("");
					m_pPatInDlg->GetDlgItem(IDC_NID)->EnableWindow(FALSE);
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}
	/////////////////////////////////////////////// CurrStat: Show
	pWnd->GetCurrStat()->SetText(strCurr);
	pWnd->GetCurrStat()->Invalidate();
	pWnd->GetCurrStat()->UpdateWindow();
	////////////////////////////////////////////////
	m_pPatInDlg->UpdateData(FALSE); // To screen
	////////////////////////////////////////////////
}

int CPatMouse::LeftUp_Pat_Node(POINT point, BOOL bCNode)
{
	///////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument();
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	CDListMgr* pDListMgr	= pObjectMgr->GetObjectList(NODE);
	//////////////////////////////////////////////////////////////////
	CString ID;
	CDrNode* pDrNode;
	int index;
	///////////////////////////////////////////// See if any Existing Node Hit
	if(m_ProbLim == PDL_TWO) 
		index = IsObjectHit(NODE,point,0);
	else
	if(m_ProbLim == PDL_THREE)
	{
		LPOINT3 MouseWIC;
		WORLD	wLoc;
		//////////
	    LPOINT Lpoint;
	    Lpoint.x = (long)point.x;
	    Lpoint.y = (long)point.y;
	    ////////////////////
	    LOGtoWIC(&MouseWIC,&Lpoint);
		////////
   		wLoc.x 	= (double)(MouseWIC.x);
   		wLoc.y 	= (double)(MouseWIC.y);
   		wLoc.z 	= (double)(MouseWIC.z);
		////////////////
		index = IsObjectHit(NODE,&wLoc,0);
	}
	/////////////////////////////////////////////
	if(index>=0)
	{
		pDrNode				= (CDrNode*)pDListMgr->GetObject(index);
		ID					= pDrNode->GetObjectID();
		///////////////////////////////////////// matches previous Node in m_NodeList,INADMISSIBLE
		if(m_nNodeDone>1)
		{
			/////////////////////////////////////////// already exists
   			if((m_NodeList.GetObjectIndex(NODE,ID) ) >=0)
   			{
				AfxMessageBox("Degenerate Extrusion Direction:\nSame Node More than Once!");
				m_nInfoDone--;
				m_nNodeDone--;
				return -2;
			}
		}
	}
	////////////////////////////////////////////////////////////////
	if((LeftUp_NODE(point,bCNode)) == -2)		// Cancel : TRUE=CNode
	{
		m_nNodeDone--;
		return -2;
	}
	//////////////////////////////////
	m_NodeList.InsertObject(m_pCurrentNode);
	/////////////////////////////////////// Set Anchor
	SetAnchorNodeID(m_CurrentNodeIDOld );
	//////////////////////////////////////
	return 0;
}

int CPatMouse::LeftUp_EXTRUDE(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		case 2:	// fall thro'
		case 3:	m_nNodeDone++;
				if((LeftUp_Pat_Node(point,TRUE)) == -2)		// Cancel : TRUE=CNode
				{
					m_nNodeDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_ROTATE(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		case 2:	// fall thro'
		case 3:	m_nNodeDone++;
				if((LeftUp_Pat_Node(point,TRUE)) == -2)		// Cancel : TRUE=CNode
				{
					m_nNodeDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_LOFT2(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	// fall thro'
		case 2:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_DUCT(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	// fall thro'
		case 2:	// fall thro'
		case 3:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		case 4:	m_nNodeDone++;
				if((LeftUp_Pat_Node(point,TRUE)) == -2)		// Cancel : TRUE=CNode
				{
					m_nNodeDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_SWEEP(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	// fall thro'
		case 2:	// fall thro'
		case 3:	// fall thro'
		case 4:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		case 5:	m_nNodeDone++;
				if((LeftUp_Pat_Node(point,TRUE)) == -2)		// Cancel : TRUE=CNode
				{
					m_nNodeDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_COONS(POINT point)
{
	switch(m_nInfoDone)
	{
		case 1:	// fall thro'
		case 2:	// fall thro'
		case 3:	// fall thro'
		case 4:	m_nCurveDone++;
				if((LeftUp_Pat_Curve(point)) == -2)		// Cancel 
				{
					m_nCurveDone--;
					return -2;
				}
				return 0;
		default:break;
	}
	return -1;
}

int CPatMouse::LeftUp_Pat_Curve(POINT point)
{
	///////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument();
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();
	CDListMgr* pDListMgr;
	pDListMgr	= pObjectMgr->GetObjectList(CURVE);
	CDrPen*	pDrPen			= (CDrPen*)pObjectMgr->GetSpecObject(DRPEN);
	//////////////////////////////////////////////////////////////////
	CString ID;
	CDrCurve* pDrCurve;
//	COLORREF OldColor,NewColor;
//	UINT nWidth;
//	UINT nStyle;	
	int nActiveIndex,index;
	CDListMgr* pList;
	///////////////////////////////////////////// See if any Existing Curve Hit
	index = IsObjectHit(CURVE,point,0);
	if(index>=0)
	{
		pDrCurve				= (CDrCurve*)pDListMgr->GetObject(index);
		ID						= pDrCurve->GetObjectID();
		///////////////////////////////////////// Check if matches previous curves,INADMISSIBLE
		if(m_nCurveDone>1)
		{
			/////////////////////////////////////////// already exists
   			if((m_CurveList.GetObjectIndex(CURVE,ID) ) >=0)
   			{
				BOOL bError = FALSE;
				////////////////////
				if(m_nCurveDone>2)
				{	
					if((m_PatProc == PP_COONS) ||(m_PatProc == PP_LOFT2) )
						bError = TRUE;
				}
				else
				if(m_nCurveDone>1)
				{	
					if(
						(m_PatProc == PP_COONS) ||(m_PatProc == PP_LOFT2) ||
						(m_PatProc == PP_DUCT) ||(m_PatProc == PP_SWEEP)
						)
						bError = TRUE;
				}
				//////////////////
				if(bError)
				{
					AfxMessageBox("Degenerate Patch:\nSame Curve More than Once!");
					return -2;
				}
			}
		}
		/////////////////////////////////////////
		pList = pObjectMgr->GetObjectList(CURVE);
		nActiveIndex = pList->GetObjectIndex(CURVE, ID);;
		pObjectMgr->SetActiveObjectIndex(nActiveIndex);		    // set Active Index									
		pObjectMgr->SetActiveObjectType(CURVE);		    // set Active Index									
		pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nActiveIndex,CURVE);
		/////////////////////
	}
	else
		return -2;
	//////////////////////////////////////////////////////////////// MultipleSearch
	int startIndex = index+1;
	/////////////////////////
	if(!m_bAutoAcceptOn)
	{
		for(;;)
		{
			CString* str = new CString;
			char* buf = str->GetBuffer(BUFF_SIZE);
			int j;
			/////////////////////////////// total elems
			int nIn		= pDrCurve->GetMaxINodes_S();
			int nElems	= pDrCurve->GetMaxOutPts_S();
			pList		= pDrCurve->GetINodeList();
			//////////////////////////////
			j = sprintf(buf,
				"Curve %s contains:\n\t%d Interpolation Nodes\n\t%d Elements",
				ID,nIn,nElems);
			j += sprintf(buf+j,"Nodes:\n");
			//////////////////////////////
			for (POSITION posI = pList->GetHeadPosition( );posI !=NULL;)
			{
				////
				CDrNode* pNode = (CDrNode*)pList->GetNextObject(posI);
				j += sprintf(buf+j,"%s, ",pNode->GetObjectID());
			}
			sprintf( buf + j-2, ";");
			/////////////////////////	
			j += sprintf(buf+j,"\n\nCancel:\tFind Next Matching Curve\n");
			j += sprintf(buf+j,    "OK:\tAccept This Curve");
			////////////////////////////
			int nResult = AfxMessageBox(*str,MB_OKCANCEL|MB_ICONQUESTION);
			/////////////
			if(nResult == IDOK)
			{
				delete str;
				break;
			}
			else
			{
				////////////////////////////////
				index = IsObjectHit(CURVE,point,startIndex);
				if(index>=0)
				{
					pDrCurve				= (CDrCurve*)pDListMgr->GetObject(index);
					ID						= pDrCurve->GetObjectID();
					///////////////////////////////////////// Check if matches previous curves,INADMISSIBLE
					if(m_nCurveDone>1)
					{
						/////////////////////////////////////////// already exists
   						if((m_CurveList.GetObjectIndex(CURVE,ID) ) >=0)
   						{
							AfxMessageBox("Degenerate Patch:\nSame Curve More than Once!");
							////////////////
							delete str;
							return -2;
						}
					}
					///////////////////////////////////////// 
					pList = pObjectMgr->GetObjectList(CURVE);
					nActiveIndex = pList->GetObjectIndex(CURVE, ID);;
					pObjectMgr->SetActiveObjectIndex(nActiveIndex);		    // set Active Index									
					pObjectMgr->SetActiveObjectType(CURVE);		    // set Active Index									
					pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nActiveIndex,CURVE);
					////////////////////////////////////////
					pDrCurve	= (CDrCurve*)pDListMgr->GetObject(index);
					ID			= pDrCurve->GetObjectID();
					startIndex  = index+1;
					/////////////////////
				}
				else
				{
					////////////////
					delete str;
					return -2;
				}
				/////////
			}
		}
	}
	//////////////////////////////////////////////////////// Compatibility Check for Coons
	if(m_PatProc == PP_COONS)
	{
		BOOL bClosed;
		////////////////////////////////////// All must be OPEN
		bClosed		= pDrCurve->IsClosed_S();
		if(bClosed)
		{
			CString str;
			LPTSTR buf = str.GetBuffer( 200 );
			sprintf(buf,"%s Curve MUST BE OPEN",ID);
			AfxMessageBox(str);
			str.ReleaseBuffer();
			//////////////////// 
			return -2;
		}
		///////////////////////////////////////////////////// find Latch
		if(	m_nCurveDone == 1)
		{
			///////////////////////////////////////////////// progress
			m_pCurPatCurve					= pDrCurve;
			m_pOldPatCurve					= m_pCurPatCurve;
			////////////////
			m_CurveList.AddTail(pDrCurve);
			m_ElSegList.AddTail(pDrCurve->GetMaxOutPts_S() - 1);
			m_LatchList.AddTail(CL_FORWARD);
			/////////////////////////////////////////////////
			return 0;
		}
		///////////////////////////////////////////////////////////////// Check CONNECTIVITY
		C3DMath Math3D;
		///////////////
		POSITION	pos;
		CDListMgr*	pINList;
		WORLD		LocalPosOld,LocalPosB,LocalPosE,LocalPos;
		CDrNode*	pNode_Old;
		CDrNode*	pNode_Beg;
		CDrNode*	pNode_End;
		CURVELATCH	OldLat,NewLat;
		//////////////////////////////////////////////////////// Curve Old
	 	pINList		= m_pOldPatCurve->GetINodeList();
		/////////////
	//	OldLat		= m_PatCurveLatch[m_nCurveDone-2];
		pos			= m_LatchList.FindIndex(m_nCurveDone-2);
		OldLat		= m_LatchList.GetAt(pos);
		pNode_Old	= (CDrNode*)pINList->GetTail();
		if(OldLat == CL_BACKWARD) 
			pNode_Old	= (CDrNode*)pINList->GetHead();
		////////////////////////////
		LocalPosOld = *(pNode_Old->GetLocalPos());
		//////////////////////////////////////////////////////// Curve New
		pINList		= pDrCurve->GetINodeList(); 
		pNode_Beg	= (CDrNode*)pINList->GetHead();
		pNode_End	= (CDrNode*)pINList->GetTail();
		/////////////
		LocalPosB	= *(pNode_Beg->GetLocalPos());
		LocalPosE	= *(pNode_End->GetLocalPos());
		//////////////////////////////////////////////////////// Do Check
		BOOL bDisJoint = TRUE;
		double dLen;
		//////////////////////
		Math3D.Sub3DPts(&LocalPosOld,&LocalPosB,&LocalPos);
		dLen = sqrt(fabs(Math3D.Len3DPts(&LocalPosOld)) * fabs(Math3D.Len3DPts(&LocalPosB)) ); 
		if( fabs(Math3D.Len3DPts(&LocalPos)/dLen) < .01)	// 1%
		{
			bDisJoint	= FALSE;
			NewLat		= CL_FORWARD;
		}
		else
		{
			//////////////////////////////////////// try with Other End
			Math3D.Sub3DPts(&LocalPosOld,&LocalPosE,&LocalPos);
			dLen = sqrt(fabs(Math3D.Len3DPts(&LocalPosOld)) * fabs(Math3D.Len3DPts(&LocalPosE)) ); 
			if( fabs(Math3D.Len3DPts(&LocalPos)/dLen) < .01)	// 1%
			{
				bDisJoint	= FALSE;
				NewLat		= CL_BACKWARD;
			}
		}
		/////////////
		if(bDisJoint)
		{
			CString str;
			LPTSTR buf = str.GetBuffer( 200 );
			sprintf(buf,
				"ComPatibility Problem!\nCurve_%d(End) & Curve_%d(Begin) DisJoint!\nCURVES MUST MEET",
				m_nCurveDone-1,m_nCurveDone);
			AfxMessageBox(str);
			str.ReleaseBuffer();
			///////
			return -2;
		}
		/////////////////////////////////////////////////  VALID:Progess
		m_pCurPatCurve					= pDrCurve;
		m_pOldPatCurve					= m_pCurPatCurve;
		m_CurveList.AddTail(pDrCurve);
		m_ElSegList.AddTail(pDrCurve->GetMaxOutPts_S() - 1);
		m_LatchList.AddTail(NewLat);
		m_Orient	= "FORWARD";
		if(NewLat == CL_BACKWARD)
			m_Orient = "BACKWARD";
		return 0;
	}
	//////////////////////////////////////////////////////////////// End Coons Compatibility
	/////////////////////////////////////////////////  VALID:Progess
	m_pCurPatCurve					= pDrCurve;
	m_pOldPatCurve					= m_pCurPatCurve;
	m_CurveList.AddTail(pDrCurve);
	CURVELATCH cLat = CL_FORWARD;
	if(m_Orient == "BACKWARD")
		cLat = CL_BACKWARD;
	m_LatchList.AddTail(cLat);
	/////////////////////////////////////////////////
	return 0;
}

void CPatMouse::ElementLeftUp_PAT(CPoint point)
{                          

	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)(AfxGetApp()->m_pMainWnd);
	CString strCurr;
	//////////////////////////////////////////////////////////////////
//	CString*	pID;
	/////////////
//	char buf[20];
	CString Nid;
	BOOL bRightOn = FALSE;
	///////////////////
	switch(m_nActiveTool) 
	{
		
		///////////////////////////////////////////////////// Patches Insert
		case P_EXTRUDE:

			m_nInfoDone++;
			if(m_nInfoDone > MAX_INFO_EXTRUDE)
			{
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_EXTRUDE(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			UpdatePDlg_FALSE();
			////////////////
			return;

		case P_ROTATE: 

			m_nInfoDone++;
			if(m_nInfoDone > MAX_INFO_ROTATE)
			{
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_ROTATE(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			UpdatePDlg_FALSE();
			////////////////
			return;

		case P_LOFT: 

			m_nInfoDone++;
			if(m_nInfoDone > MAX_INFO_LOFT2)
			{
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_LOFT2(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			UpdatePDlg_FALSE();
			////////////////
			return;

		case P_DUCT: 

			m_nInfoDone++;
			if(m_nInfoDone > MAX_INFO_DUCT)
			{
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_DUCT(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			UpdatePDlg_FALSE();
			////////////////
			return;

		case P_SWEEP:

			m_nInfoDone++;
			if(m_nInfoDone > MAX_INFO_SWEEP)
			{
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_SWEEP(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			//////
			if(m_nInfoDone == MAX_INFO_SWEEP-2)	// Get Ready for Radial Curve
				m_bTwist = FALSE;
			//////
			UpdatePDlg_FALSE();
			////////////////
			return;

		case P_COONS:		// 
			

			m_nInfoDone++;
			////////////////
			if(m_nCurveDone > MAX_INFO_COONS)
			{
				m_nCurveDone--;
				m_nInfoDone--;
				return;
			}
			////////////////
			UpdatePDlg_TRUE();
			if(LeftUp_COONS(point)<0)
			{
				m_nInfoDone--;
				return;
			}		
			UpdatePDlg_FALSE();
			///////
			return;
	
		////////////////////////////////////////////////// SPAWN	
		case P_SPAWN:				// PATCH
			///////		
			LeftUp_PSPAWN(point);
			return;
		
		////////////////////////////////////////////////// STITCH	
		case P_STITCH:				// CURVE
			///////		
//			LeftUp_PSTITCH(point);
			return;
		////////////////////////////////////////////////// POST
/*
		case P_POST:				// PATCH 
			///////		
			m_MI_Pat_P.LBUpPatchPost();
			return;
*/
		//////////////////////////////////////////////////
		default:  
			break;
	} 
}	

int CPatMouse::LeftUp_PSPAWN(CPoint point)
{
	///////////////////////////////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument();
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();
	CDListMgr* pDListMgr	= pObjectMgr->GetObjectList(PATCH);
	CDListMgr* pList;
	//////////////////////////////////////////////////////////////////
	CString		ID;
	CString*	pID = &ID;
	CDrPatch*	pDrPatch;
	int			nActiveIndex,index;
	////////////////////////////////////
	CHitNet*	pHitNet		= (CHitNet*)pObjectMgr->GetSpecObject(HITNET);
	double		dTol		= pHitNet->GetSearchDet(); 
	WORtoWOP(&dTol,&dTol);	// physical
	///////////////////////////////////////////// See if any Existing Node Hit
	index = IsObjectHit(PATCH,point,0);
	////////////////////////////////////////////////////
	if(index<0)
		return -2;
	////////////////////////////////////////////////////
	pDrPatch	= (CDrPatch*)pDListMgr->GetObject(index);
	ID			= pDrPatch->GetObjectID();
	/////////////////////////////////////////
	pList = pObjectMgr->GetObjectList(PATCH);
	nActiveIndex = pList->GetObjectIndex(PATCH, ID);;
	pObjectMgr->SetActiveObjectIndex(nActiveIndex);	// set Active Index									
	pObjectMgr->SetActiveObjectType(PATCH);		    // set Active Type									
	pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nActiveIndex,PATCH);
	//////////////////////////////////////////////////////////////// MultipleSearch
	int startIndex = index+1;
	int nResult;
	/////////////////////////
	if(!m_bAutoAcceptOn)
	{
		/////////////
		for(;;)
		{
			//////////////////////////////
			nResult = ShowPatchInfo(pDrPatch);
			/////////////
			if(nResult == IDYES)
				//////////////////////////////////////////////////////// Accept Old
				break;
			else
			if(nResult == IDNO)
			{
				//////////////////////////////////////////////////////// Retry
				index = IsObjectHit(PATCH,point,startIndex);
				if(index>=0)
				{
					pDrPatch	= (CDrPatch*)pDListMgr->GetObject(index);
					ID		= pDrPatch->GetObjectID();
					///////////////////////////////////////// 
					pList = pObjectMgr->GetObjectList(PATCH);
					nActiveIndex = pList->GetObjectIndex(PATCH, ID);;
					pObjectMgr->SetActiveObjectIndex(nActiveIndex);		    // set Active Index									
					pObjectMgr->SetActiveObjectType(PATCH);		    // set Active Index									
					pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nActiveIndex,PATCH);
					////////////////////////////////////////
					startIndex  = index+1;
					/////////////////////
				}
				else
					////////////////
					return -2;
				/////////
			}
			else				// Cancel
				//////////////////////////////////////////////////////// Do Nothing
				return -2;
		}						// end for loop
		///////////////////////////////////////
	}				// end !AutoAccept loop
	//////////////////////////////////////////////////////////////////// finally, show Properties
	m_pCurrentPatch = pDrPatch;
	/////////////////////////////
	nResult = ShowPatchToSpawn(pDrPatch);
	///////////
	if( nResult == -1)		// 
	{
		AfxMessageBox("ERROR:\nCPatMouse::LeftUp_PSpawn\nShowPatchToSpawn Problem");
		return -1;
	}
	else
	if(nResult == -2)		// Cancel
		return -2;
	////////////////////////////
	return 0;
}

int CPatMouse::ShowPatchInfo(CDrPatch* pDrPatch)
{
	int nResult;
	CString ID;
	CString* pID = &ID;
	ID = pDrPatch->GetObjectID();
	//////////////////////////////////////////////////////////////////////
	PATCHPROC 		PatProc		= pDrPatch->GetPatchProc();
	PATSUBTYPE 		PatSubType	= pDrPatch->GetPatSubType();
	//////////////////////////////
	CString* str = new CString;
	char* buf = str->GetBuffer(BUFF_SIZE);
	int j;
	//////
	j = sprintf(buf,"***** A Patch Hit To Spawn ****\n");
	//////////////////////////////////////
	switch(PatProc)
	{
		case PP_EXTRUDE:
			//////////////////////////////////////////////////// Show Patch
			j += sprintf(buf+j,"Patch %s was Generated by Extrusion\n",*pID);
			break;

		case PP_ROTATE:
			//////////////////////////////////////////////////// Show Patch
			j += sprintf(buf+j,"Patch %s was Generated by Rotation\n",*pID);
			break;

		case PP_LOFT2:
			//////////////////////////////////////////////////// Show Patch
			j += sprintf(buf+j,"Patch %s\nGenerated by Lofting\n",*pID);
			break;

		case PP_DUCT:
			//////////////////////////////////////////////////// Show Patch
			j += sprintf(buf+j,"Patch %s\nGenerated by Ducting\n",*pID);
			break;

		case PP_SWEEP:
			//////////////////////////////////////////////////// Show Patch
			j += sprintf(buf+j,"Patch %s\nGenerated by\nSweeping\n",*pID);
			break;

		case PP_COONS:
			//////////////////////////////////////////////////// Show Patch
			if(PatSubType == PS_TRIANGLE)
				//////////////////////////////////////////////////// Show Patch
				j += sprintf(buf+j,"Patch %s\nTriangular Coons Type\n",*pID);
			else
			if(PatSubType == PS_QUADRILAT)
				//////////////////////////////////////////////////// Show Patch
				j += sprintf(buf+j,"Patch %s\nQuadrilateral Coons Type\n",*pID);

			////
			break;

		default:
			break;
	}
	////////////////////////////
	j += sprintf(buf+j,
		"\nYES:\t\tSpawn This Patch");
	j += sprintf(buf+j,
		"\nNO:\t\tFind Next Patch with Intersecting Trace");
	j += sprintf(buf+j,
		"\nCANCEL:\t\tCancel Selection Process");
	nResult = AfxMessageBox(*str,MB_YESNOCANCEL|MB_ICONQUESTION);
	///////////////
	delete str;
	return nResult;
}
	
int CPatMouse::ShowPatchToSpawn(CDrPatch* pDrPatch)
{

	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	CDrPatch*	pNewPatch;
	CDListMgr* pDListMgr;
	///////////////////
	pObjectMgr->SetActiveObjectType(PATCH);
	/////////////////////////////////////////////////////////////// Using CMI_PSPN
	CMI_PSPN MI_PSPN;
	int nResult = MI_PSPN.SpawnPatchShowingDlg(pNewPatch,pDrPatch, pDrPatch, PATCH); 
	if(nResult<0)
		return nResult;//
	/////////////////////////////////////////////////////////// Control RectBound
	pNewPatch->SetDirty(TRUE);
	pNewPatch->SetShow(TRUE);
	////////////////////////////////////////////////////////// Save
	CString PatchID	= pNewPatch->GetObjectID();
	pDListMgr	 	= pObjectMgr->GetObjectList(PATCH);
	int nPatchIndex = pDListMgr->GetObjectIndex(PATCH,PatchID); 
	int nOldIndex 	= pObjectMgr->GetActiveObjectIndex();
	pObjectMgr->SetActiveObjectIndex(nPatchIndex); 
	pObjectMgr->SetActiveObjectType(PATCH); 
    ////////////////////////////////////////////////////////// done/Invalidate
	pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nPatchIndex,PATCH);
	///////////////////////////////
	return 0;
}	 

void CPatMouse::OnEBoxMouseMove_PAT(CClientDC* pdc,CView* pView,GENERATE gener,
											UINT nFlags, CPoint point)
{  

	m_nFlags				= nFlags;
	m_pView					= pView;
	m_pdc					= pdc;
	////////////////////////////////
	m_Gener					= gener;
	/////////////////////////////////////////////////////////
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CMouseMgr* pMouseMgr	= pWnd->GetMouseMgr(); 
	////////////////////////// LOG: Log/DEScaled
   	m_pdc->DPtoLP(&point);     
	LPOINT LpLOG;
	LpLOG.x = (long)point.x;
	LpLOG.y = (long)point.y;
   	m_pdc->LPtoDP(&point);     
    /////////////////////////////////////////////
    if(!m_bDragging)  // not currently dragging 
    { 
    
		//////////////////////////////////////
		LPOINT3 MouseOldTempWIC = GetMouseOldWIC();
	    LPOINT3 MouseTempWIC 	= GetMouseWIC();
   		SetMouseOldWIC(MouseTempWIC);
   		LPOINT3 MouseWIC;
    	///////////////////////  LOG :DEScaled
    	LOGtoWIC2(&MouseWIC,&LpLOG,&MouseTempWIC); //LOG/Scaled WIC
    	////////////////////                 
    	SetMouseWIC(MouseWIC);
    	///////////////////////////
//    	pDoc->UpdateStatusBar(&dc);  WILL BE CALLED FROM VIEW, JUST SET HERE
		pMouseMgr->SetStatusMouseWIC(MouseWIC);
		////////////////////////////
		///////////////////// recover MouseWIC changed for statusbar update 
	    SetMouseOldWIC(MouseOldTempWIC);
	    SetMouseWIC(MouseTempWIC);

		return;
    }	
   	//////////////////////////////      ***** START FROM HERE *****
   	CPen    Pen;
	CPen*   PtrOldPen;
	//////////////////////////////
	m_pdc->SetBkMode(TRANSPARENT);
	//////////////////////////////	
	// Create Black Pen 2 Pixel wide;
	int two = 2;
	COLORREF crColor = 0x000000;  
	Pen.CreatePen ((int)PS_SOLID,two,crColor);
	PtrOldPen = m_pdc->SelectObject(&Pen);
	///////////////////////////
	m_MouseLOG = point;              // Device
	POINT MouseLOC;
	/////////////////////////	
	m_pdc->SetROP2 (R2_NOT); 
	
	MouseLOC = m_AnchorNodeLOG;      // Device
	m_pdc->DPtoLP(&MouseLOC);
	m_pdc->MoveTo (MouseLOC);

	MouseLOC = m_MouseOldLOG;        // Device
	m_pdc->DPtoLP(&MouseLOC);
	m_pdc->LineTo (MouseLOC);
	////////////////////////	  
//	m_pdc->SetROP2 (R2_COPYPEN);

	MouseLOC = m_AnchorNodeLOG;      // Device
	m_pdc->DPtoLP(&MouseLOC);
	m_pdc->MoveTo (MouseLOC);

	MouseLOC = m_MouseLOG;
	m_pdc->DPtoLP(&MouseLOC);
	m_pdc->LineTo (MouseLOC);

	m_MouseOldLOG = m_MouseLOG;
	///////////////////////////
   	m_pdc->SelectObject(PtrOldPen);   
	Pen.DeleteObject(); 
	//////////////////////////////////////
    LPOINT3 MouseWIC = GetMouseWIC();
    SetMouseOldWIC(MouseWIC);
   	///////////////////////
   	LOGtoWIC(&MouseWIC,&LpLOG); //LOG/Scaled WIC
   	////////////////////                 
    SetMouseWIC(MouseWIC);
    ///////////////////////////
//  pDoc->UpdateStatusBar(&dc);  WILL BE CALLED FROM VIEW, JUST SET HERE
	pMouseMgr->SetStatusMouseWIC(MouseWIC);
	//////////////////////////////////////////////    
}

void CPatMouse::OnEBoxLButtonUp_PAT(CClientDC* pdc,CView* pView,GENERATE gener,
											UINT nFlags, CPoint point)
{
	m_nFlags				= nFlags;
	m_pView					= pView;
	m_pdc					= pdc;
	////////////////////////////////
	m_Gener					= gener;
  	/////////////////////////////////////////////////////////
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
    if(m_bDragging)  // not currently dragging
    {
		m_bDragging = FALSE; 
		::ReleaseCapture();
		//	ClipCursor(NULL);				TOBEDONE 
	}	
	///////////////////////////////////////////////////////// 
	PreLeftUp(point);
    /////////////////////////////  ELement Dialog On/Off Check
    POINT Logpoint;
    m_pdc->DPtoLP(&point);
    Logpoint.x = point.x;
    Logpoint.y = point.y;
    m_pdc->LPtoDP(&point);							
    ////////////////////
    if(m_Gener == FORWARD)
		ElementLeftUp_PAT(Logpoint);
	else	
    if(m_Gener == REVERSE)
		;
//		ElementLeftUp_I();
	/////////////////
	PostLeft();
	/////////////////////////
	
}

void CPatMouse::OnEBoxRButtonDown_PAT(CClientDC* pdc,CView* pView,GENERATE gener,
									UINT nFlags, CPoint point)
{ 
	m_nFlags				= nFlags;
	m_pView					= pView;
	m_pdc					= pdc;
	////////////////////////////////
	m_Gener					= gener;
	/////////////////////////////////////////////////////////
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();

	CBooleans* pBool		= (CBooleans*)pObjectMgr->GetSpecObject(BOOLEANS);
    /////////////////////////////  ELement Dialog On/Off Check
	m_bDialogOn     = pBool->IsDialogOn();
	m_bAutoAcceptOn	= pBool->IsAutoAcceptOn();
	m_bSingleSegOn	= pBool->IsSingleSegOn();
	m_bBLineOn		= pBool->IsBLineOn();
	/////////////////////////////////////////////////////////////////////////////
	m_nActiveObject = pWnd->GetActiveObjectType(); 
	m_nActiveTool	= pWnd->GetActiveToolType();    // -1= INSERT
	/////////////////////////////////////////////////////////////////////////
	pObjectMgr->SetActiveObjectType(m_nActiveObject);       // Set ObjectType 
	//////////////////////////////////////////
	switch(m_nActiveTool) 
	{
		case PATCH:
			break;
		////////////////////////////////////////////////// Patch
		default:
			break;
	}  
}

int CPatMouse::RightUp_Premature()
{
	CDrGrafFrame* pWnd	= (CDrGrafFrame*)AfxGetMainWnd();
	CString strCurr;
	////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();
	CDListMgr*	pList;
	////////////////////////////////////////////////////// Add to DataBase
	CString* pID;
	int		nAnswer = IDOK;
	BOOL	bPremature = FALSE;
	////////////////////////////////
	pID			= &m_CurrentPatchID; 
	//////////////////////////////////////////////////// Check Adequate Curve,or cancel
	switch(m_PatProc)
	{
		case PP_EXTRUDE:

			if(m_nInfoDone<3)
			{
				bPremature = TRUE;
				nAnswer = AfxMessageBox(
				"Minimum of 1 Curve & 2 CNodes Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		case PP_ROTATE:

			if(m_nInfoDone<3)
			{
				bPremature = TRUE;
				nAnswer = AfxMessageBox(
				"Minimum of 1 Curve & 2 CNodes Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		case PP_LOFT2:

			if(m_nInfoDone<2)
			{
				bPremature = TRUE;
				nAnswer = AfxMessageBox(
				"Minimum of 2 Curves Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		case PP_DUCT:

			if(m_nInfoDone<4)
			{
				bPremature = TRUE;
				nAnswer = AfxMessageBox(
				"Minimum of 3 Curves & 1 CNode Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		case PP_SWEEP:

			if(m_nInfoDone<3)
			{
				bPremature = TRUE;
				nAnswer = AfxMessageBox(
				"Minimum of 4 Curves & 1 CNode Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		case PP_COONS:

			if(m_nInfoDone<3)
			{
				nAnswer = AfxMessageBox(
				"Minimum of 3 Curves Needed\n Do You want to Continue to Get More Info. ?",
				MB_YESNO|MB_ICONQUESTION );
				/////////////////////////
			}
			break;

		default:
			break;
	}
	//////////////////////////////////////////////////////// OK
	if(!bPremature)
		return 0;
	//////////////////////////////////////////////////////// ReConfirm: Don't Continue			
	if(nAnswer == IDNO)
	{
		CString* str = new CString;
		char* buf = str->GetBuffer(BUFF_SIZE);
		////////////////////
		sprintf(buf,"Do You Want to Delete\nCurrent Patch to Start Allover");
		/////////////////////////	
		nAnswer = AfxMessageBox(*str,MB_YESNO|MB_ICONQUESTION);
		///////////
		delete str;
		/////////////////////////
		if(nAnswer == IDYES)		//delete
		{
			///////////////////////////////////////// delete
			pList = pObjectMgr->GetObjectList(PATCH);
			int nActiveIndex = pList->GetObjectIndex(PATCH, *pID);
			//////////////////////////////////////////////////// Reset
			pObjectMgr->DeleteFromDataBase(nActiveIndex, PATCH);
			/////////////////////////////////////// Reset
			m_nInfoDone		= 0;
			m_nCurveDone	= 0;	// 
			m_nNodeDone		= 0;	// 
			m_bPatchDone	= TRUE;	// 
			//////////////////////////
			m_pCurrentPatch = NULL;
			m_CurveList.RemoveAll();
			m_NodeList.RemoveAll();
			m_ElSegList.RemoveAll();
			m_LatchList.RemoveAll();
			/////////////////// reset
			if(m_pPatInDlg->GetSafeHwnd())
				m_pPatInDlg->GetDlgItem(IDC_PID)->EnableWindow(TRUE);
			/////////////////////////////////////
			pDoc->UpdateAllViews(NULL);
			///////////////////////////
		}
		///////////
	}
	////////
	return -1;
}	

int CPatMouse::RightUp_NotAutoAccept()
{
	CDrGrafFrame* pWnd	= (CDrGrafFrame*)AfxGetMainWnd();
	CString strCurr;
	////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();
	CDListMgr*	pList;
	CDrCurve*	pDrCurve;
	CDrNode*	pDrNode;
	////////////////////////////////////////////////////// Add to DataBase
	CString* pID;
	int i;
	int nAnswer = IDOK;
	////////////////////////////////
	pID			= &m_CurrentPatchID; 
	////////////////////////////////
	if(!m_bAutoAcceptOn)
	{
		///////////////////////////////////////////////////////////// show Info
		CString* str = new CString;
		char* buf = str->GetBuffer(BUFF_SIZE);
		////////////////////
		int j;
		//////////
		pDrCurve = (CDrCurve*)(m_CurveList.GetObject(0) );	//Head
		//////////////////////////////////////////////////// Check Adequate Curve,or cancel
		switch(m_PatProc)
		{
			case PP_COONS:


				j = sprintf(buf,"Patch %s contains\n\t%d Coons Curves:\n",
					*pID,m_nCurveDone);

				for(i=0;i<m_nCurveDone;i++)
				{
					pDrCurve = (CDrCurve*)(m_CurveList.GetObject(i) );
					//////////////////
					j += sprintf( buf + j, "\t%s Curve_%d\n",pDrCurve->GetObjectID(),i+1);
				}
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			case PP_EXTRUDE:

				j = sprintf(buf,"Patch %s contains\n\tExtrusion Curve:\t%s",
					*pID,pDrCurve->GetObjectID());

				j += sprintf(buf + j,"\n\t%d Direction Nodes:\t",m_nNodeDone);
				for(i=0;i<m_nNodeDone;i++)
				{
					pDrNode = (CDrNode*)(m_NodeList.GetObject(i) );
					j += sprintf( buf + j, "%s, ",pDrNode->GetObjectID());
				}
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			case PP_ROTATE:

				j = sprintf(buf,"Patch %s contains\n\tRotational Curve:\t%s",
					*pID,pDrCurve->GetObjectID());

				j += sprintf(buf + j,"\n\t%d Axis Nodes:\t",m_nNodeDone);
				for(i=0;i<m_nNodeDone;i++)
				{
					pDrNode = (CDrNode*)(m_NodeList.GetObject(i) );
					j += sprintf( buf + j, "%s, ",pDrNode->GetObjectID());
				}
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			case PP_LOFT2:

				j = sprintf(buf,"Patch %s contains\n\t%d Lofting Curves:\n",
					*pID,m_nCurveDone);

				for(i=0;i<m_nCurveDone;i++)
				{
					pDrCurve = (CDrCurve*)(m_CurveList.GetObject(i) );
					//////////////////
					switch(i)
					{
						case 0:
							j += sprintf( buf + j, "\t%s To Loft From",pDrCurve->GetObjectID());
							break;
						case 1:
							j += sprintf( buf + j, "\t%s To Loft To",pDrCurve->GetObjectID());
							break;
						default:
							break;
					}
				}
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			case PP_DUCT:

				j = sprintf(buf,"Patch %s contains\n\t%d Ducting Curves && %d Anchor Node:\n",
					*pID,m_nCurveDone,m_nNodeDone);

				for(i=0;i<m_nCurveDone;i++)
				{
					pDrCurve = (CDrCurve*)(m_CurveList.GetObject(i) );
					//////////////////
					switch(i)
					{
						case 0:
							j += sprintf( buf + j, "\t%s CrossSectional Curve",pDrCurve->GetObjectID());
							break;
						case 1:
							j += sprintf( buf + j, "\t%s Spine Curve",pDrCurve->GetObjectID());
							break;
						case 2:
							j += sprintf( buf + j, "\t%s Twist Curve",pDrCurve->GetObjectID());
							break;
						default:
							break;
					}
				}
				pDrNode = (CDrNode*)(m_NodeList.GetObject(0) );
				j += sprintf( buf + j, "\n\t%s Anchor Node",pDrNode->GetObjectID());
				/////////////////////////
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			case PP_SWEEP:

				j = sprintf(buf,"Patch %s contains\n\t%d Sweeping Curves && %d Anchor Node:\n",
					*pID,m_nCurveDone,m_nNodeDone);

				for(i=0;i<m_nCurveDone;i++)
				{
					pDrCurve = (CDrCurve*)(m_CurveList.GetObject(i) );
					//////////////////
					switch(i)
					{
						case 0:
							j += sprintf( buf + j, "\t%s CrossSectional Curve",pDrCurve->GetObjectID());
							break;
						case 1:
							j += sprintf( buf + j, "\t%s Spine Curve",pDrCurve->GetObjectID());
							break;
						case 2:
							j += sprintf( buf + j, "\t%s Twist Curve",pDrCurve->GetObjectID());
						case 3:
							j += sprintf( buf + j, "\t%s Radial Scale Curve",pDrCurve->GetObjectID());
							break;
						default:
							break;
					}
				}
				pDrNode = (CDrNode*)(m_NodeList.GetObject(0) );
				j += sprintf( buf + j, "\n\t%s Anchor Node",pDrNode->GetObjectID());
				/////////////////////////
				sprintf( buf + j-2, ";");
				/////////////////////////
				break;


			default:
				break;
		}
		/////////////////////////////////////////////////////////////////////
		if(j>BUFF_SIZE)
		{
			sprintf( buf, "Internal Error:\nIncrease buffer to %d",j);
			AfxMessageBox(*str);
			delete str;
			return -1;
		}	 
		///////////////////////////////////////////////////////////////	
		nAnswer = AfxMessageBox(*str,MB_OKCANCEL|MB_ICONQUESTION );
		/////////////////////////
		if(nAnswer == IDCANCEL)
		{
			sprintf(buf,"Do You Want to Delete\nCurrent Patch to Start Allover");
			/////////////////////////	
			nAnswer = AfxMessageBox(*str,MB_YESNO|MB_ICONQUESTION);
			/////////////////////////
			if(nAnswer == IDYES)		//delete
			{
				///////////////////////////////////////// delete
				pList = pObjectMgr->GetObjectList(PATCH);
				int nActiveIndex = pList->GetObjectIndex(PATCH, *pID);
				//////////////////////////////////////////////////// Reset
				pObjectMgr->DeleteFromDataBase(nActiveIndex, PATCH);
				/////////////////////////////////////// Reset
				m_nInfoDone		= 0;	// 
				m_nCurveDone	= 0;	// 
				m_nNodeDone		= 0;	// 
				m_bPatchDone	= TRUE;	// 
				//////////////////////////
				m_CurveList.RemoveAll();
				m_NodeList.RemoveAll();
				m_ElSegList.RemoveAll();
				m_LatchList.RemoveAll();
				/////////////////////////////////////
				pDoc->UpdateAllViews(NULL);
				///////////////////////////
				delete str;
				///////////
				return -1;
			}
		}
		/////////////////////
		delete str;
		return 0; 
	}
	/////////
	return 0;
}

int CPatMouse::ShowPatch(CString* pID)
{

	CDrGrafFrame*	pWnd	= (CDrGrafFrame*)AfxGetMainWnd();
	CString			strCurr;
	////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr();
	char		buf[30];
	PATCHPROC		PatProcOld;
	//////////////////////////////////////////////////////////////////// Show NewPatch
	int nActiveIndex,nResult;
	///////////////////////////
	m_pCurrentPatch	= (CDrPatch*)(pObjectMgr->AddToDataBase(*pID,nActiveIndex,PATCH));
	m_pCurrentPatch->SetShow(FALSE);	// not quite ready
	//////////////////////////////////////////////////// Fill Mesh
	m_ElSegList.RemoveAll();
	m_ElSegList.AddTail(m_ElPerSeg);
	////////////////////////////////
	strCurr = "Please Wait";
	///////////////////////// CurrStat: Show
	pWnd->GetCurrStat()->SetText(strCurr);
	pWnd->GetCurrStat()->Invalidate();
	pWnd->GetCurrStat()->UpdateWindow();
	//////////////////////////////////////////////////////////////  Posting Dimension
	int nMeshElemDim;
	switch(pWnd->GetCurrentCntlID())
	{
		case EDIM_0: 
			nMeshElemDim = 0;	// Node(0D)
			break;
		case EDIM_1: 
			nMeshElemDim = 1;	// Grid(1D)
			break;
		default:
			nMeshElemDim = 2;	// plate, etc(2D)
	}
	m_pCurrentPatch->SetMeshElemDim(nMeshElemDim);					// 1D or 2D 
	////////////////////////////////////////////////////////////////////// Show
	switch(m_PatProc)
	{
		case PP_EXTRUDE:
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpExtrudeInsert(
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_LatchList,
							&m_NodeList,
							&m_ElSegList,
							m_dLen,
							m_Ratio,
							m_pView
							) <0)
				nResult = -1;
			break;

		case PP_ROTATE:
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpRotateInsert(
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_LatchList,
							&m_NodeList,
							&m_ElSegList,
							m_dLen,
							m_Ratio,
							m_pView
							) <0)
				nResult = -1;
			////
			break;

		case PP_LOFT2:
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpLoft2Insert(
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_LatchList,
							&m_ElSegList,
							m_Ratio,
							m_pView
							) <0)
				nResult = -1;
			////
			break;

		case PP_DUCT:
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpDuctInsert(
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_NodeList,
							&m_LatchList,
							m_TwistMult,
							m_bIncrement,
							m_TwistStart,
							m_pView
							) <0)
				nResult = -1;
			////
			break;

		case PP_SWEEP:
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpSweepInsert(
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_NodeList,
							&m_LatchList,
							m_TwistMult,
							m_bIncrement,
							m_TwistStart,
							m_RadiusMult,
							m_bIncRad,
							m_RadStart,
							m_pView
							) <0)
				nResult = -1;
			////
			break;

		case PP_COONS:
			//////////////////////////////////////////////////// Show Patch
			////////////////////////////// OverRide PatProc for COONS Only
			PatProcOld = m_PatProc;
			/////////
			if(m_nCurveDone == 3)
				m_PatProc	= PP_LOFT3;
			else
			if(m_nCurveDone == 4)
				m_PatProc	= PP_LOFT4;
			//////////////////////////////////////////////////// Show Patch
			if(m_MI_Pat_I.RBUpCoonInsert(
							m_PatProc, 
							m_CurrentPatchID,		
							m_pCurrentPatch,
							&m_CurveList,
							&m_LatchList,
							m_pView
							) <0)
				nResult = -1;
			////////////////////////////// Reset PatProc for COONS Only
			m_PatProc = PatProcOld;
			////
			break;

		default:
			break;
	}
	////////////////////////////////////////////////////////// Error
	if(nResult == -1)
	{
		/////////////////////////////////////// Reset
		m_nInfoDone		= 0;	// 
		m_nCurveDone	= 0;	// 
		m_bPatchDone	= TRUE;	// 
		//////////////////////////
		m_CurveList.RemoveAll();
		m_NodeList.RemoveAll();
		m_ElSegList.RemoveAll();
		m_LatchList.RemoveAll();
		/////////////////// reset
		if(m_pPatInDlg->GetSafeHwnd())
		m_pPatInDlg->GetDlgItem(IDC_PID)->EnableWindow(TRUE);
		/////////////////////////////////////
		return -1; 
	}
	/////////////////////////////////////// Set PatchID
	if(*pID == m_CurrentPatchID)
	{		
		m_LastPatchNum++;		// internal
		sprintf(buf,"%d",m_LastPatchNum);
		m_CurrentPatchID	= "P";
		m_CurrentPatchID	+= buf;
	}
	/////////////////////////////////////// Reset
	m_nInfoDone		= 0;	// 
	m_nCurveDone	= 0;	// 
	m_bPatchDone	= TRUE;	//   
	//////////////////////////
	m_CurveList.RemoveAll();
	m_NodeList.RemoveAll();
	m_ElSegList.RemoveAll();
	m_LatchList.RemoveAll();
	/////////////////// reset
	if(m_pPatInDlg->GetSafeHwnd())
		m_pPatInDlg->GetDlgItem(IDC_PID)->EnableWindow(TRUE);
	/////////////////////////////////////
	return 0;
	////
}

void CPatMouse::OnEBoxRButtonUp_PAT(CClientDC* pdc,CView* pView,GENERATE gener,
								UINT nFlags, CPoint point)
{
	m_nFlags				= nFlags;
	m_pView					= pView;
	m_pdc					= pdc;
	////////////////////////////////
	m_Gener					= gener;
	/////////////////////////////////////////////////////////
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	//////////////////////////////////////////////////////////////////
	CMI_PSPN	MI_PSPN;
	/////////////////////
	CString ID;
	CString* pID = &ID;
	///////////////////////////////////////////////////////// Update Info
	UpdatePDlg_TRUE();
	///////////////////////////////////////////////////////// Is Enough Info?
	if(RightUp_Premature()<0)
		return;
	///////////////////////////////////////////////////////// Not Auto Accept
	if(RightUp_NotAutoAccept()<0)
		return;
		///////////////////////////////////////////////////// Show Patch 
	switch(m_nActiveTool) 
	{

		case P_COONS:
						
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;

			
		case P_EXTRUDE:
						
//			if(m_MI_Pat_I.RBUpExtrudeInsert(m_pView) <0)
//				return; 
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;
		
		case P_ROTATE:
						
//			if(m_MI_Pat_I.RBUpRotateInsert(m_pView) <0)
//				return; 
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;
		
		case P_LOFT:
						
//			if(m_MI_Pat_I.RBUpLoft2Insert(m_pView) <0)
//				return; 
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;
		
		case P_DUCT:
						
//			if(m_MI_Pat_I.RBUpDuctInsert(m_pView) <0)
//				return; 
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;
		
		case P_SWEEP:
						
//			if(m_MI_Pat_I.RBUpSweepInsert(m_pView) <0)
//				return; 
			/////////////////////////////
			ShowPatch(&m_CurrentPatchID);
			/////////
			UpdatePDlg_FALSE();
			///////////////////	
			return;


		
		
		case P_STITCH:
		
			//////////////////////////// 	
			return;



		case P_SPAWN:
		
			//////////////////////////// 	
			return;
		/////////////////////////////////////////////////// POST
/*
		case P_POST:				// PATCH 
			///////		
			m_MI_Pat_P.LBUpPatchPost();
			return;
*/			
		
		default:  
			break;
	} 

}


int CPatMouse::PutEndIdsInPlateList(CString nid[],int nEnds)
{
	///////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDrPen*	pDrPen			= (CDrPen*)pObjectMgr->GetSpecObject(DRPEN);
	CLayer* pLayer			= (CLayer*)pObjectMgr->GetSpecObject(LAYER);
	CPatchMnu* pPatchMnu	= (CPatchMnu*)pObjectMgr->GetSpecObject(PATCHMNU);
	CObj3DMnu* pObj3DMnu	= (CObj3DMnu*)pObjectMgr->GetSpecObject(OBJ3DMNU);
	/////////////////////////////////////////////////////////////////
	static char NodeEnds[] = {'I','J','K','L'};
	CString str;
	char buf[100];
	for (int i = 0;i<nEnds-1;i++)
	{
		for(int j = i+1;j<nEnds;j++)
		{	 
			if(nid[i] == nid[j])
			{
				sprintf(buf,"Node IDs for End: %c & End: %c must be different!!",
								NodeEnds[i],NodeEnds[j]);
				str = buf;
				AfxMessageBox(str);
   				return -1;
   			}
   		}
   	}
   	/////////////////////		 
	int index;
	CString EndNids;  
	///////////////////////////////////////////// EndNids
	CString blank(' ');
	EndNids	= nid[0]; 	
	for ( i=1; i < nEnds; i++)
		EndNids += blank + nid[i]; 
	/////////////////////////////////////////// already exists
   	if(( index = pObjectMgr->GetObjectIndexfromKey(FE2D,EndNids,1))>=0)       
   	{
		AfxMessageBox("Plate with these NodeIDs Already Exists !!");
   		return -1;
	}
	////////////////////////////////////////////////////////////////////// Object List
    CDListMgr* pDListMgr;
	/////////////////////////////////////////////////////////////////////////// add
 	int nActiveIndex;
    CDrFE2D* pAddObject	= (CDrFE2D*)(pObjectMgr->AddToDataBase(nActiveIndex,FE2D));
	/////////////////////////////////////////////////////////////
	pAddObject->SetObjectType((int)FE2D);
	pAddObject->SetLevelType((int)LEVEL_GRAPA);
	pAddObject->SetElemType((int)ELEM_OBJECT);              // globals.h
	////////////////////////////////////////////////////////////////////////////////													    
	pObjectMgr->SetActiveObjectIndex(nActiveIndex);		    // set Active Index									
	pObjectMgr->SetActiveObjectType(FE2D);		    // set Active Index									
	pAddObject->SetObjectType((int)FE2D);
	pAddObject->SetElemType((int)EL3D_OBJECT);              // globals.h
    ///////////////////////////////// Set Info & Create
	for (i=0; i < nEnds; i++)
		(pAddObject->GetPlatCard())->nid[i]= nid[i];
	//////////////////////////////////////////////////////////// Pen & Layer
	pAddObject->SetPenInfo(pDrPen->GetWidth(),pDrPen->GetColor(),
											pDrPen->GetStyle());
	pAddObject->SetLayer(pLayer->GetCurrentLayer());
	///////////////////////////////////////////////////// store node pointers 
	pDListMgr = pObjectMgr->GetObjectList(NODE);
    for(i=0;i<nEnds;i++)
    {
		if(( index = pObjectMgr->GetObjectIndexfromKey(NODE,nid[i],1))>=0)
		{
			CDrNode* pDrNode = (CDrNode*)pDListMgr->GetObject(index);
  			pAddObject->GetNodeList()->InsertObject(pDrNode);
			//////////////////////////////// save Current Plate Pointer in Nodes
			pDrNode->GetElemList()->InsertObject(pAddObject);
		}			
	
  	}
    ////////////////////////////////////////////////////////// Invalidate
	pObjectMgr->SetActiveObjectIndex(nActiveIndex);		    // set Active Index									
	pObjectMgr->SetActiveObjectType(FE2D);		    // set Active Index									
	pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nActiveIndex,FE2D);
	////////////////////////////////////////////////////////// 
/*		
	/////////////////////////////////////////////////////////////////////// Obj3D/Patch
	if(PutObjectinPatch(pAddObject, nid,nEnds) <0)
	{
		AfxMessageBox("CouldNot Put in Patch!!");
		return -1;
	}
*/		
	//////////////////////////////////////////////////////////
    return 0;
}
    
int CPatMouse::PutObjectinPatch(CDrObject* pAddObject,CString nid[],int nEnds)
{
	///////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDrPen*	pDrPen			= (CDrPen*)pObjectMgr->GetSpecObject(DRPEN);
	CLayer* pLayer			= (CLayer*)pObjectMgr->GetSpecObject(LAYER);
	CPatchMnu* pPatchMnu	= (CPatchMnu*)pObjectMgr->GetSpecObject(PATCHMNU);
	CObj3DMnu* pObj3DMnu	= (CObj3DMnu*)pObjectMgr->GetSpecObject(OBJ3DMNU);
	/////////////////////////////////////////////////////////////////////// Obj3D/Patch
	CString strPatchID	= pPatchMnu->GetCurrentID();
	CString strObj3DID	= pObj3DMnu->GetCurrentID();
    ////////////////////////////////////////////////////////////////////// Obj3D
    CDListMgr* pDListMgr  = pObjectMgr->GetObjectList(OBJ3D);
    ///////////////////////
    CDrObj3D*	pDrObj3D;
    int index,i;
    if((index = pDListMgr->GetObjectIndex(OBJ3D,strObj3DID) ) >=0)   // exists already
		pDrObj3D = (CDrObj3D*)(pDListMgr->GetObject(index));
	else
	{
    	CNewObjs* pNewObjs;
    	pDrObj3D = (CDrObj3D*)(pNewObjs->NewObject(OBJ3D));   // New
    	//////////////////////////////////////////////////////// Fill Info
		pDrObj3D->SetObjectType((int)OBJ3D);
		pDrObj3D->SetElemType((int)EL3D_OBJECT);              // globals.h
    	pDrObj3D->SetObjectID(strObj3DID);
		pDrObj3D->SetLayer(pLayer->GetCurrentLayer());
    	/////////////////////
    	pDListMgr->InsertObject(pDrObj3D);
    	/////////////////////
    }	 
	////////////////////////////////////////////////////////////////////// Patch 
	if(pDrObj3D)
	{
    	CDListMgr* pPatchList;
    	//////////////////////
	    CDrPatch*	pDrPatch;
    	if((index = pPatchList->GetObjectIndex(PATCH,strPatchID) ) >=0)
    	{	
			pDrPatch = (CDrPatch*)pPatchList->GetObject(index);
    	}	
		else
		{
    		CNewObjs* pNewObjs;
    		pDrPatch = (CDrPatch*)(pNewObjs->NewObject(PATCH));   // New
    		//////////////////////////////////////////////////////// Fill Info
			pDrPatch->SetObjectType((int)PATCH);
			pDrPatch->SetElemType((int)EL3D_OBJECT);              // globals.h
    		pDrPatch->SetObjectID(strPatchID);
			pDrPatch->SetLayer(pLayer->GetCurrentLayer());
    		/////////////////////
    		pPatchList->InsertObject(pDrPatch);
    		/////////////////////
    	}	 
		////////////////////////////////////////////////////////////////////// save in Patch
    	if((index = pPatchList->GetObjectIndex(PATCH,strPatchID) ) >=0)
    	{
			pDrPatch = (CDrPatch*)pPatchList->GetObject(index);
			///////////////////////////////////////////////////// PolyList
			CDListMgr* pPolyList = pDrPatch->GetElemList();
			if(pPolyList)
			{
				if((pPolyList->GetObjectIndex(pAddObject) ) <0) // new
					pPolyList->InsertObject(pAddObject); 
			}		
			///////////////////////////////////////////////////// NodeList
			CDListMgr* pNodeList = pDrPatch->GetNodeList();
			if(pNodeList)
			{
				CDrNode* pDrNode; 
	       		for(i=0;i<nEnds;i++)
 	      		{
					if(( index = pObjectMgr->GetObjectIndexfromKey(NODE,nid[i],1))>=0)
  						pDrNode = (CDrNode*)(pObjectMgr->GetObjectList(NODE)->GetObject(index)); // Object List
  					else
  					{
  						AfxMessageBox("Internal at ObjectinPatch.586");
  						return -1;
  					}		
					if((pNodeList->GetObjectIndex(pDrNode) ) <0) // new in NodeList 
						pNodeList->InsertObject(pDrNode);
				}
			}			
	  	}
	}	  		
	//////////////////////////////////////
	else
	{
		AfxMessageBox("Internal Problem: PutObjectinPatch.ObjMgr.596"); 
		return -1;
	}	
	return 0; 
} 
/////////////////////////////////////////////////////////////////////////////////////// F_M
UINT CPatMouse::ReSetToolID_PAT(UINT CntlID,UINT IGenID, UINT OperID)
{
	CDrGrafFrame* pWnd	= (CDrGrafFrame*)AfxGetMainWnd();
	CString strCur;
	////////////////
	CString str;
	UINT ID;
	//////////////////////////////////////////// TaskID
	strCur = "Ready for Creation@";
	/////////////////////////////
	switch(OperID)
	{
		//////////////////////////////////////////// Create
		case CREATE:
		{
			pWnd->SetIGenBoxStatus(TRUE);
			pWnd->SetCntlBoxStatus(FALSE);
			pWnd->SetDrawBoxStatus(FALSE);
			///////////////////////////// String
			str = "CREATE";
			pWnd->SetstrOperID(str);
			/////////////////////////////
			switch(CntlID)
			{
				//////////////////////////////////////// Elements
				case ELEMENT:
				case EDIM_0:
				case EDIM_1:
				case EDIM_2:
				case EDIM_3:

//					pWnd->SetMouseBoxType(ELEMDIMBOX);
					str = "ELEMENT";
					pWnd->SetstrCntlID(str);
					///////////////////////////////////// EDim0/EDim1...
					switch(IGenID)
					{
						/////////
						case PATCH:			str = "PATCH";					ID = PATCH;
								strCur += "Select a Patch Type";	break;
						case P_TENSOR:		str = "Tensor Product@PATCH";	ID = P_TENSOR; 
								strCur += "A Tensor Product Patch";	break;
						case P_GORDONS:		str = "Gordons@PATCH";			ID = P_GORDONS;
								strCur += "A Gordons Patch";	break;
						case P_COONS:		str = "Coons@PATCH";			ID = P_COONS;
								strCur += "A Coons Patch";	break;
						case P_ROTATE:		str = "Rotational@PATCH";		ID = P_ROTATE; 
								strCur += "A Patch by Rotation";	break;
						case P_LOFT:		str = "Lofted@PATCH";			ID = P_LOFT; 
								strCur += "A Patch by Lofting";	break;
						case P_EXTRUDE:		str = "Extruded@PATCH";			ID = P_EXTRUDE; 
								strCur += "A Patch by Extrusion";	break;
						case P_DUCT:		str = "Ducted@PATCH";			ID = P_DUCT; 
								strCur += "A Patch by Ducting";	break;
						case P_SWEEP:		str = "Swept@PATCH";			ID = P_SWEEP; 
								strCur += "A Patch by Sweeping";	break;
						case P_FLATPLATE:	str = "Flat@PATCH";				ID = P_FLATPLATE;
								strCur += "A Patch by Tessalation";	break;
						case P_STITCH:      str = "Stich@PATCH";			ID = P_STITCH; 
								strCur = "Ready for Stitching@Patches";	break;
						case P_SPAWN:       str = "Spawn@PATCH";			ID = P_SPAWN; 
								strCur += "A Patch by Spawning";	break;
						default:			str = "UNKNOWN@PATCH";			ID = UNONE; 		break;
					}
					pWnd->SetstrIGenID(str);
					////////////////////////
					pWnd->SetstrCurrID(strCur);
					//////////
					return ID;
				/////////
				default:					str = "UNKNOWN";	ID = UNONE;
					pWnd->SetstrIGenID(str);
					return ID;
			}
			pWnd->SetstrCntlID(str);
			return ID;
		////////
		default:							str = "UNKNOWN";	ID = UNONE;
		}
		pWnd->SetstrOperID(str);
		return ID;
	}
}
	
void CPatMouse::ModeLessOff_PAT()
{
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	if(GetPatInDlg()->m_hWnd)
		pWnd->SendMessage(ID_GOODBYE_PATIN,IDOK);
}

void CPatMouse::ModeLessOn_PAT()
{
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	/////////////////////////////////////////////////////////
	int aTool	= pWnd->GetActiveToolType();
	int aObj	= pWnd->GetActiveObjectType();
	/////////////////////////////////////////////////////////////////////////
	if
	(
		(aTool == P_COONS)		||	(aTool == P_EXTRUDE)	||
		(aTool == P_ROTATE)		||	(aTool == P_LOFT)		||		     
		(aTool == P_DUCT)		||	(aTool == P_SWEEP)				     
	)
	{
		switch(aTool)
		{
			case P_EXTRUDE:
				m_PatProc = PP_EXTRUDE;
				break;

			case P_ROTATE:
				m_PatProc = PP_ROTATE;
				break;

			case P_LOFT:
				m_PatProc = PP_LOFT2;
				break;

			case P_COONS:
				m_PatProc = PP_COONS;
				break;

			case P_DUCT:
				m_PatProc = PP_DUCT;
				break;
			case P_SWEEP:
				m_PatProc = PP_SWEEP;
				break;
			default:
				break;
		}
		////////////////////////////
//		if(!(GetPatInDlg()->m_hWnd))
			pWnd->SendMessage(ID_ACTIVE_PATIN,IDOK);
	}

}

long CPatMouse::CreateorActivatePatIn(UINT wParam, long lParam)
{
	
	CDrGrafFrame* pWnd		= (CDrGrafFrame*)AfxGetMainWnd();
	CString strCurr;
	/////////////////////////////////////////////////////////
	GetPatInDlg()->m_PatProc = m_PatProc;
	///////////////////////////////////////
	if(GetPatInDlg()->GetSafeHwnd() ==0)	// not created already
	{
		GetPatInDlg()->Create();
		CRect BoxRect;
		CWnd  wndTopMost;
		GetPatInDlg()->GetWindowRect(&BoxRect);
		SizeRectDlgIn(BoxRect);
		//////////////////////////////////////////////////////////////
		GetPatInDlg()->SetWindowPos(&wndTopMost,BoxRect.left,BoxRect.top,BoxRect.Width(),
                        BoxRect.Height(),SWP_NOZORDER|SWP_SHOWWINDOW);
		//////////////////////////////////////////////////////////////  
	}
	else
	{
		GetPatInDlg()->SetActiveWindow();
		GetPatInDlg()->m_PatProc = m_PatProc;
		GetPatInDlg()->ResetDlg();
	}
	///////////////////////// CurrStat: Show
	switch(m_PatProc)
	{
		case PP_EXTRUDE:
			//////////////////////////////
			strCurr = "Patch by Extrusion: Click in@A Curve To Extrude";
			////
			break;
		case PP_ROTATE:
			//////////////////////////////
			strCurr = "Patch by Rotation: Click in@A Curve To Rotate";
			////
			break;
		case PP_LOFT2:
			//////////////////////////////
			strCurr = "Patch by Lofting: Click in@A Curve To Loft From";
			////
			break;
		case PP_DUCT:
			//////////////////////////////
			strCurr = "Patch by Ducting: Click in@A CrossSection Curve";
			////
			break;
		case PP_SWEEP:
			//////////////////////////////
			strCurr = "Patch by Sweeping: Click in@A CrossSection Curve";
			////
			break;
		case PP_COONS:
			//////////////////////////////
			strCurr = "Patch by Coons Method: Click in@First Curve";
			////
			break;
		default:
			break;
	}
	///////////////////////////////////////////////////////////////// if PatDlg Open
	if(GetPatInDlg()->m_hWnd)
	{
		CStatic* pCtl;
		pCtl = (CStatic*)(GetPatInDlg()->GetDlgItem(IDC_OTHER));
		////////////////////////////////////////////////////////
		if((UINT)(pWnd->GetActiveViewNumber()) == VIEW12)
			pCtl->SetWindowText("Z");
		else
		if((UINT)(pWnd->GetActiveViewNumber()) == VIEW23)
			pCtl->SetWindowText("X");
		else
		if((UINT)(pWnd->GetActiveViewNumber()) == VIEW31)
			pCtl->SetWindowText("Y");
		else
		if((UINT)(pWnd->GetActiveViewNumber()) == VIEWISO)
		{
			pWnd->SendMessage(ID_GOODBYE_PATIN,IDOK);
			return 0L;
		}
	}
	////////////////////////////////////////////////////////////////// Set Info
	GetPatInDlg()->m_PatProc	= m_PatProc;
	GetPatInDlg()->m_PID		= m_CurrentPatchID;
	GetPatInDlg()->m_CID		= m_CurrentCurveID;
	GetPatInDlg()->m_NID		= m_CurrentNodeID;
	GetPatInDlg()->m_nMesh		= m_ElPerSeg;
	GetPatInDlg()->m_Ratio		= m_Ratio;
	//////
//	GetPatInDlg()->m_Orient		= m_Orient;
	if(m_Orient == "FORWARD")
		((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(1);//FORWARD=1
	else
	if(m_Orient == "BACKWARD")
		((CComboBox*)(GetPatInDlg()->GetDlgItem(IDC_ORIENT)))->SetCurSel(0);//BACKWARD=0
	//////
	GetPatInDlg()->m_bClosed	= m_bClosed;
	GetPatInDlg()->m_dLen		= m_dLen;
	/////
	GetPatInDlg()->m_bTwist		= m_bTwist;
	if(m_bTwist)
	{
		GetPatInDlg()->m_bIncrement	= m_bIncrement;
		GetPatInDlg()->m_TwistStart	= m_TwistStart;
		GetPatInDlg()->m_TwistMult	= m_TwistMult;
	}
	else
	{
		GetPatInDlg()->m_bIncrement	= m_bIncRad;
		GetPatInDlg()->m_TwistStart	= m_RadStart;
		GetPatInDlg()->m_TwistMult	= m_RadiusMult;
	}
	/////
	GetPatInDlg()->m_SegAngle	= m_SegAngle;
	GetPatInDlg()->m_bAutoSeg	= m_bAutoSeg;
	////////////////////////////////
	GetPatInDlg()->UpdateData(FALSE);
	///////////////////////// CurrStat: Show
	pWnd->GetCurrStat()->SetText(strCurr);
	pWnd->GetCurrStat()->Invalidate();
	pWnd->GetCurrStat()->UpdateWindow();
	////////////////////////////////
	return 0L;
}
	 
long CPatMouse::GoodByePatIn(UINT wParam, long lParam)
{
	
	GetPatInDlg()->DestroyWindow();
	//////////
	return 0L;
}
	 
long CPatMouse::CancelPatIn(UINT wParam, long lParam)
{
	
	GetPatInDlg()->DestroyWindow();
	//////////
	return 0L;
}
	 
long CPatMouse::UpdatePatIn(UINT wParam, long lParam)
{

	GetPatInDlg()->UpdateData(TRUE);
	//////////////////////////////////////
	UpdatePDlg_TRUE();
	//////////
	return 0L;
}
void CPatMouse::Serialize(CArchive& ar)
{

	CCurMouse::Serialize( ar);              // must call base class Serializer
	/////////////////////////
	if (ar.IsStoring())
	{
		TRACE(" PatMouse:    Storing\n");	
		

	}
	else
	{
		TRACE(" PatMouse:    Loading\n");	

	
	}        
}

///////////////////////////////////// end of Module //////////////////////		

