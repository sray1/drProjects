// Mouse.cpp : implementation file
//


#include "stdafx.h"
#include "math.h"

#include "glb_Objs.h"
//////////////////// 
#include "3dMath.h" 

#include "drgraf.h"
///////////////////// 
//#include "drawview.h" //for curve/patch 
/////////////////////
#include "drgradoc.h"
#include "ObjMgr.h"
#include "EBoxmgr.h" 
#include "NewObjs.h"
#include "DListMgr.h"
/////////////////////
#include "Def_Ms.h" // Mesh Types for Patch
///////////////////// dialogMgr
#include "MPatMgr.h"
//#include "Dlg_Node.h"  
///////////////////// elements
#include "Def_IGen.h"
//#include "elextern.h"
#include "DrNode.h"
#include "DrCurve.h"
#include "DrPatch.h"
///////////////////// DrawObjs
#include "Def_Draw.h"
#include "DrLabel.h"
///////////////////// SpecObjs
#include "Def_Spec.h"
#include "drpen.h"
#include "Layer.h"
/*
#include "precison.h"
#include "mapfacto.h"
//#include "ScaleFac.h"
#include "DrFont.h"
*/
/////////////////////
//#include "elmouse.h"
#include "MI_Patch.h" 

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MIN_CNODES_CURVE	4
#define MIN_CNODES_PATCH	16
/////////////////////////////////////
#define wEQL(a,b)	((a).x ==(b).x) && ((a).y ==(b).y) \
					&& ((a).z ==(b).z)  
////////////////////////////////////
IMPLEMENT_SERIAL(CMI_Patch,CMI_Curve,1)
/////////////////////////////////////////////////////////////////////////////
CMI_Patch::CMI_Patch()
{
	m_pOut = NULL;
	for (int i=0;i<4;i++)
		m_pIn_S[i] = NULL;
	//////////////////////
	m_nCNodeDone   		= 0;
    /////////////////////////////////////////// Mesh/Patch
	m_CurrentPatchID	= "BLANK";
	m_nMaxPatchCNodes_S	= MIN_CNODES_CURVE;
	m_nMaxPatchCNodes_T	= MIN_CNODES_CURVE;
	m_nMaxPatchCNodes	= m_nMaxPatchCNodes_S * m_nMaxPatchCNodes_T;
}

CMI_Patch::~CMI_Patch()
{
	if(m_pOut != NULL)
	{
		FreeMem(m_pOut);
		m_pOut = NULL;
	}	   
}

int CMI_Patch::LBUpLoftInsert(CView* pView) 
{

	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDListMgr* pDListMgr 	= pObjectMgr->GetObjectList();
	//////////////////////////////////////////////////////////////////
	CString		ID,CurveID;
	CString*	pID = &ID, pCurveID;
	long 		nOut_1;
	//////////////////////
//	m_bDirtyCurve = FALSE;
//	m_bDirtyPatch = FALSE;
	//////////////////////////////////////////////////////////////// clear
	if(!(m_CNListLoft.IsEmpty() ) )
		m_CNListLoft.RemoveAll();
	///////////////////////////////	
	m_pDrPatch 		= Loft_GetInfo();   // PGen Dialog
	if(!m_pDrPatch)		// cancel
		return -1;
	//////////////////////////////////	
	m_pCNodeList 	= m_pDrPatch->GetCNodeList();	
	/////// 
	Loft();							// ControlNode Mesh
	/////////////////
	if(InsertMeshInfo(TRUE)<0)
		return -1;
	//////////////////////////////////////////////////////////
	CString PatchID	= m_pDrPatch->GetObjectID();
	int nPatchIndex = pDListMgr->GetObjectIndex(PATCH,PatchID);
	int nOldIndex 	= pObjectMgr->GetActiveObjectIndex();
	pObjectMgr->SetActiveObjectIndex(nPatchIndex);
    ////////////////////////////////////////////////////////// done/Invalidate
	pObjectMgr->UpdateAllViewsWithActiveIndex(NULL,nPatchIndex);
	/////////////////////
	return 0;		 
}			

CDrPatch* CMI_Patch::Loft_GetInfo()
{
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDListMgr* pDListMgr 	= pObjectMgr->GetObjectList();
	//////////////////////////////////////////////////////////////////
	CMPatMgr* 	pMPatMgr;
	CString		Cid;
	int 		index;
	///////////////////////////////////////////////////
//todo		if (pMPatMgr->DoModal_MeshGen(&Cid,0) == IDCANCEL)
	if (pMPatMgr->DoModal_Patch_Loft(&Cid,4) == IDCANCEL)
			return (CDrPatch*)NULL;
/*
    /////////////////////////////////////////////////////// update
	m_CurrentPatchID 	= Cid;
*/	
	index 				= pObjectMgr->
							GetObjectIndexfromKey(PATCH,Cid,1);
	if(index>=0)
	{						
		CDrPatch* pDrPatch	= (CDrPatch*)(pDListMgr->GetObject(index));
   		//////////////////////////////
		m_CurveID_S[0]	= pDrPatch->GetCurveID(0);
		m_CurveID_S[1]	= pDrPatch->GetCurveID(1);
		m_nSegs_T		= pDrPatch->GetSegs();
		////////////////
		return pDrPatch;
	}
	else
		return (CDrPatch*)NULL;
}			

int CMI_Patch::Loft()
//////////////////////////////////////////////////////////////////////////////////
//	Lofting is LINEAR interpolation of GENERATED NODES, NOT of CONTROL NODES	//
//	of the curves in T-Direction. So, all generated nodes of each curve will	//
//	be saved as CNodes of the patch in S-Direction and eventually the PATCH		//
//  will be generated by LINEAR interpolation in both S- & T- direction,		//
//	IRRESPECTIVE of CURVETYPE of each one										// 												//
//////////////////////////////////////////////////////////////////////////////////
{

	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	CDListMgr* 	pDListMgr 	= pObjectMgr->GetObjectList();
	////////////////////////////////////////////////////// 
	CDListMgr	ListTemp;
	CDListMgr* 	pListTemp = &ListTemp;
	CString		CurveID;
	BOOL		bPutinCNodeList,bLoft = FALSE;
	int 		tIndex;
	long		nOutOld; 
	////////////////////////////////////////////////////// Output Memory
	if(m_pOut != NULL)
	{
		FreeMem(m_pOut);
		m_pOut = NULL;
	}	
	/////////////////////////////////////////////////////////////// Loop
    for(int i=0;i<2;i++)
    {
    	CurveID = m_CurveID_S[i];
		//////////////////////////////////////// get Curve Info	
		int index	= pObjectMgr->
						GetObjectIndexfromKey(CURVE,CurveID,1);
		if(index<0)
			return -1;
		/////////////////////////////////////////////////////////////	
		CDrCurve* pDrCurve	= (CDrCurve*)(pDListMgr->GetObject(index));
		if(!pDrCurve)
			return -1;
		///////////////////////////////////////////////// Memory ControlPts 
		m_nOut				= pDrCurve->GetLongOutPts();
		m_nMaxCurveCNodes 	= pDrCurve->GetMaxCNodes_S();	
		if(m_pIn_S[i])
		{
			FreeMem(m_pIn_S[i]);
			m_pIn_S[i] = NULL;
		}	
		if( !(m_pIn_S[i] = FixMem(m_nOut) )  )
		{
			AfxMessageBox("CMI_Patch::Curve\nFixMemforCNodes Failure!");
			return -1;
		}
		////////////////////////// Fill temporily/noSave 
		bPutinCNodeList = FALSE;
		FillCNodesLOCAL(pDrCurve->GetCNodeList(),
			m_pIn_S[i],m_nMaxCurveCNodes,bPutinCNodeList,
			bLoft);
		/////////////////////////////////////////// Memory OutputPts 
		if(i == 0) 
		{
			nOutOld = m_nOut; 
			/////////////////////	
			if( !(m_pOut = FixMem(m_nOut)) )
			{
				AfxMessageBox("CMI_Patch::Curve\nFixMemforNodes Failure!");
				return -1;
			} 
			tIndex = i; 		// Ist Row of Control Pts for Naming
		}
		else
		{
			if (nOutOld != m_nOut)
			{
				AfxMessageBox("Both Curves must have\nSame Number of Elements!");
				return -1;
			}
			else
			{
				tIndex	= m_nSegs_T;	// Last Row of Control Pts for Naming
				bLoft 	= TRUE; // 2nd set of CNodes in a different list
				///////////////////////////////////////// Save Outputs in TempList
				if(!(ListTemp.IsEmpty() ) )
					ListTemp.RemoveAll();
			}	
		}	
		///////////////////////////////////////// Generate CurvePts
		if(Gen_Curve(pDrCurve,m_pIn_S[i],m_pOut,(int)m_nOut)<0)
			return -1;
		//////////////	
		m_nMaxCurveCNodes 	= (int)m_nOut;
		m_nOut_S			= (int)m_nOut;
		//////////////////////
		CurveNodesSaveAsCNodes(pListTemp,tIndex);
		//////////////////////	
		bPutinCNodeList = TRUE;
		FillCNodesLOCAL(pListTemp,
			m_pIn_S[i],m_nMaxCurveCNodes,bPutinCNodeList,
			bLoft);
		///////////////////////////////////////////////
/*			 		
				m_CurveType			= pDrCurve->GetCurveType();
				if(m_CurveType == CU_BEZIER)
					m_PatchType = PA_BEZIER;
				else	
				if(m_CurveType == CU_BSPLINE)
					m_PatchType = PA_BSPLINE;
				else
				if(m_CurveType == CU_LINEAR) 
					m_PatchType = PA_LINEAR;
				//////////////////////////////	
//				if(m_PatchType == PA_LINEAR) 
*/
		/////////////////////////////////////////////////////
		m_bClosed_S			= pDrCurve->IsClosed_S();		// X-Section
		m_bClosed_T			= FALSE;
		m_PatchType 		= PA_LINEAR;					// ALWAYS 
		m_nSegs_S			= 1; 							// ALWAYS
		m_nOut_SCon			= (int)m_nMaxCurveCNodes;
		m_nOut_T			= m_nSegs_T + 1;
		m_nOut_TCon			= 2; 							// ALWAYS
		m_nMaxPatchCNodes_T = m_nOut_TCon;
		m_nMaxPatchCNodes_S = m_nOut_SCon;
		m_nSegs_SCon		= m_nOut_SCon - 1;
		m_nSegs_TCon		= m_nOut_TCon - 1;

	}
	///////////////////////////////////////// Save Outputs in TempList
	if(!(ListTemp.IsEmpty() ) )
		ListTemp.RemoveAll();
	////////////////////////////////// Save PatchInfo
	m_nOut				= (((long)m_nOut_S)*((long)m_nOut_T) );				
	m_nOutCon			= (((long)m_nOut_SCon)*((long)m_nOut_TCon) );				
	m_nMaxPatchCNodes	= (int)m_nOutCon;
	/////////////////////////////////////////// Memory OutPts 
	if( !(m_pOut = FixMem(m_nOutCon)) )
	{
		AfxMessageBox("CMI_Patch::Loft\nFixMem Failure!");
		return -1;
	}
	///////////////////////////////////////// Go Loft 
	int nResult = Loft_GenerateCNodes();
	///////////////////////////////////////// Free InputCNodeMems
    for(i=0;i<4;i++)
    {
    	if(m_pIn_S[i])
    	{
			FreeMem(m_pIn_S[i]);
			m_pIn_S[i] = NULL;
		}	
	}	
	///////////////////////////////////////////////////////////// 
	if(nResult<0)	
		return -1;
	else	
		return 0;
	/////////////			 
}			

int CMI_Patch::Loft_GenerateCNodes()
{

	//////////////////////////////////////////// generate Patch Pts
	int nOut		= (int)m_nOutCon;  // for now		 	   	
	int nOutActual	= m_pDrPatch->LoftCurves
			(
				(short)m_nSegs_TCon,	//	subdivision value (interior spaces)
				(short)m_nOut_SCon,	//	number of input data points
				m_pIn_S[0],			//	input Start curve ControlPts
				m_pIn_S[1],			//	input End curve ControlPts
				m_pOut,				//	Output ControlPts array
				nOut				//	expected number of generated curve vertices	
			);	  
	////////////////////////////	
	if(nOutActual != nOut)
		return -1;
	else
		return 0;
												
}
