// Loft2.cpp : implementation file
//


#include "stdafx.h"
#include "math.h"

#include "Def_Objs.h"
//////////////////// 
#include "3dMath.h" 

#include "drgraf.h"
/////////////////////
#include "drgradoc.h"
#include "ObjMgr.h"
#include "NewObjs.h"
#include "DListMgr.h"
#include "Def_MouseAct.h"
#include "DegElevate.h"
///////////////////// dialogMgr
//#include "MPatMgr.h"
///////////////////// elements
#include "Def_IGen.h"
#include "DrNode.h"
#include "DrCurve.h"
#include "DrPatch.h"
///////////////////// SpecObjs
#include "Def_Spec.h"
#include "drpen.h"
#include "Layer.h"
/////////////////////
#include "PA_CoonP.h"
 
#include "MP_CooP4.h" 

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define MAGENTA		RGB(255,0,255)	// Jn. Curve Color
#define	new			DEBUG_NEW
#define	BUFF_SIZE	1024

#define MIN_CNODES_CURVE	4
#define MIN_CNODES_PATCH	16
/////////////////////////////////////
#define wEQL(a,b)	((a).x ==(b).x) && ((a).y ==(b).y) \
					&& ((a).z ==(b).z)  
////////////////////////////////////
IMPLEMENT_SERIAL(CMP_CooP4,CMI_GangP,1)
/////////////////////////////////////////////////////////////////////////////
CMP_CooP4::CMP_CooP4()
{
	m_bBack = FALSE;
}

CMP_CooP4::~CMP_CooP4()
{
}
int CMP_CooP4::GoDoIt 
				(
					BOOL							bGenBCurve,
					//////////////////////////////////////////
					CString&						PatchID,		
					CDrPatch*						pDrPatch,
					//////////////////////////////////////////
					CDListMgr*						pCurveList,
					CList<CURVELATCH,CURVELATCH>*	pLatchList
				) 
{
	int nResult = MA_OK;
	//////////////////////////////////////////////////////////
	m_PatchID	= PatchID;
	m_pDrPatch	= pDrPatch;
	///////////////////////////////////////////////////////////////////////////////// Fill Lists
	CDListMgr						CurveList_U;
	CDListMgr*						pCurveList_U = &CurveList_U;
	pCurveList_U->RemoveAll();
	CDListMgr						CurveList_V;
	CDListMgr*						pCurveList_V = &CurveList_V;
	pCurveList_V->RemoveAll();
	///
	CList<CURVELATCH,CURVELATCH>	LatchList_U;
	CList<CURVELATCH,CURVELATCH>*	pLatchList_U = &LatchList_U;
	CList<CURVELATCH,CURVELATCH>	LatchList_V;
	CList<CURVELATCH,CURVELATCH>*	pLatchList_V = &LatchList_V;
	////////////
	FillCurve_N_LatchLists(pCurveList,pLatchList,
					pCurveList_U,pLatchList_U,pCurveList_V,pLatchList_V);
	///////////////////////
	int nCurves,nConBZ_Tot;
	///////////////////////////////////////////////////////////////////////////////// S-direction
	////////////////////////////////////////////////////////// Compatibility(Knots)
	int nDim_S,nTopDegree_S,nConBZ_S;
	BOOL bClosed_S;
	///////////////
	if(!AreCurvesCompatible_U(pCurveList_U,pLatchList_U,bClosed_S,nDim_S,
								nTopDegree_S,nConBZ_S) )
		return MA_ERROR;
	////////////////////////////////////////////////////////// Process  Data Curves( Elevate etc)
	nCurves				= pCurveList_U->GetCount(); 
	nConBZ_Tot			= nConBZ_S * nCurves;  
	pWORLD  pConBZ_S	= new WORLD [nConBZ_Tot]; 	
	pDOUBLE pWtsBZ_S	= new double[nConBZ_Tot];
	/////////////////////////////////////////
	nResult = ProcessCurves(pCurveList_U,pLatchList_U,pConBZ_S,pWtsBZ_S,nConBZ_S,
													nConBZ_Tot,nTopDegree_S,nDim_S);
	///////////////////////////////////////////////////////////////////////////////// T-direction
	////////////////////////////////////////////////////////// Compatibility(Knots)
	int nDim_T,nTopDegree_T,nConBZ_T;
	BOOL bClosed_T;
	///////////////
	if(!AreCurvesCompatible_V(pCurveList_V,pLatchList_V,bClosed_T,nDim_T,
								nTopDegree_T,nConBZ_T) )
		return MA_ERROR;
	////////////////////////////////////////////////////////// Process  Data Curves( Elevate etc)
	nCurves				= pCurveList_V->GetCount(); 
	nConBZ_Tot			= nConBZ_T * nCurves;  
	pWORLD  pConBZ_T	= new WORLD [nConBZ_Tot]; 	
	pDOUBLE pWtsBZ_T	= new double[nConBZ_Tot];
	/////////////////////////////////////////
	nResult = ProcessCurves(pCurveList_V,pLatchList_V,pConBZ_T,pWtsBZ_T,nConBZ_T,
													nConBZ_Tot,nTopDegree_T,nDim_T);
	///////////////////////////////////////////////////////////////////////////////// Patch CNs & Wts
	// Generated by NetCoons
	nConBZ_Tot			= nConBZ_S * nConBZ_T;
	pWORLD  pConBZ_Tot	= new WORLD [nConBZ_Tot]; 	
	pDOUBLE pWtsBZ_Tot	= new double[nConBZ_Tot];
	////////////////////////////////////////////
	nResult = DoNetCoons(pConBZ_S,pWtsBZ_S,nConBZ_S,pConBZ_T,pWtsBZ_T,nConBZ_T,
											pConBZ_Tot,pWtsBZ_Tot,nConBZ_Tot);
	if(nResult == MA_ERROR)
		return MA_ERROR;

	/////////////////////////////////////////////////////////////////////////////// Now Save CNs & Wts
	nResult = CreateSavePatCNodes_N_Wts(pDrPatch,pConBZ_Tot,pWtsBZ_Tot,
													nConBZ_S,nConBZ_T);
	/////////////////////////////////////////////////////////////////////////////// Post Patch Info
	m_PatchType		= PA_TENSOR;
	////////////////////////////
	m_bGenBCur = bGenBCurve;
	nResult = SetInfoForDataBase(pDrPatch,	pCurveList_U,pCurveList_V,
											pLatchList_U,pLatchList_V);
	/////////////////////////////////////////////////////////////////////////////// Done
	pLatchList_U->RemoveAll();
	pLatchList_V->RemoveAll();
	////////////////////////////////////////////////////////////////////////////// Bndry Curves
	if(bGenBCurve)
	{
		CDrCurve* pCurve;
		////////////////////////////////////////////////// Create LatticeCurves_U
														// at Bez. JnPts. Only
		pCurve = (CDrCurve*)pCurveList_U->GetObject(0); //patterned after U-direction Curve 
		nResult = LatticeCurves_U(pDrPatch,m_nOrder_T,m_bClosed_T,m_nSegs_T,
												m_nMaxPatchCNodes_S,pCurve);
		if(nResult == MA_ERROR)
			return nResult;
		////////////////////////////////////////////////// Create LatticeCurves_V
														// at Bez. JnPts. Only	
		pCurve = (CDrCurve*)pCurveList_V->GetObject(0); //patterned after V-direction Curve 
		nResult = LatticeCurves_V(pDrPatch,m_nOrder_S,m_bClosed_S,m_nSegs_S,
							m_nMaxPatchCNodes_S,m_nMaxPatchCNodes_T,pCurve);
		if(nResult == MA_ERROR)
			return nResult;
	}
	///////////////////////////////
	pCurveList_U->RemoveAll();
	pCurveList_V->RemoveAll();
	/////////////////////
	return nResult;
}
//////////////////////////////////////////////////////////////////////////////////// PreProcess
int CMP_CooP4::FillCurve_N_LatchLists(
					CDListMgr* pCurveList,CList<CURVELATCH,CURVELATCH>* pLatchList,
					CDListMgr* pCurveList_U,CList<CURVELATCH,CURVELATCH>* pLatchList_U,
					CDListMgr* pCurveList_V,CList<CURVELATCH,CURVELATCH>* pLatchList_V)
{
	CDrCurve*	pCurve;
	CURVELATCH	CuLatch;
	POSITION	pos;
	////////////////////
	pCurve	= (CDrCurve*)pCurveList->GetObject(0);	// Curve_1
	if(pCurve)
		pCurveList_U->InsertObject(pCurve);	
	pCurve	= (CDrCurve*)pCurveList->GetObject(2);	// Curve_3
	if(pCurve)
		pCurveList_U->InsertObject(pCurve);	
	////
	pCurve	= (CDrCurve*)pCurveList->GetObject(1);	// Curve_2
	if(pCurve)
		pCurveList_V->InsertObject(pCurve);	
	pCurve	= (CDrCurve*)pCurveList->GetObject(3);	// Curve_4
	if(pCurve)
		pCurveList_V->InsertObject(pCurve);	
	//////////////////////////////////////////////////////////
	pos = pLatchList->FindIndex(0);
	CuLatch	= pLatchList->GetAt(pos);
	pLatchList_U->AddTail(CuLatch);
	pos = pLatchList->FindIndex(2);
	CuLatch	= pLatchList->GetAt(pos);
	pLatchList_U->AddTail(CuLatch);
	//////////
	pos = pLatchList->FindIndex(1);
	CuLatch	= pLatchList->GetAt(pos);
	pLatchList_V->AddTail(CuLatch);
	pos = pLatchList->FindIndex(3);
	CuLatch	= pLatchList->GetAt(pos);
	pLatchList_V->AddTail(CuLatch);
	////////////////////////////////
	return MA_OK;
}

BOOL CMP_CooP4::AreCurvesCompatible_U(CDListMgr* pCurveList,CList<CURVELATCH,CURVELATCH>* pLatchList,
											BOOL bClosed,int& nDim_S,int& nTopDegree,int& nCon_BZ)
{
	//////////////////////////////////////////////////////////// ALL Closed or Open
	if(!IsCompat_Closed(pCurveList,bClosed))
		return FALSE;
	else
		m_bClosed_S = bClosed;
	//////////////////////////////////////////////////////////// Segment Compatibility
	PreProcessCurvesControlInfo(pCurveList,nDim_S,nTopDegree); // TopDegree? etc
	////////////////////////////////////////////////////////////////
	m_nDim_S	= nDim_S;
	m_nOrder_S	= nTopDegree + 1;
	/////////////////////////////
	switch(m_nOrder_S)
	{
		case 2:
			m_CurveType_S = CP_LINEAR;
			break;
		case 3:
			m_CurveType_S = CP_QUADRATIC;
//			if() // Circle
//				m_CurveType_S = CP_CIRCLE;
			break;
		case 4:
			m_CurveType_S = CP_BSPLINE;
			if(m_nDim_S == 4)
				m_CurveType_S = CP_NURB;
			break;
		default:
			break;
	}
	//////////////////////////////////////////////////////////// Do it
	int nBezSeg;
	// Total Expected CNodes of EACH Curve
	if(!IsCompat_NumberOfCNodes(pCurveList,nTopDegree,nBezSeg,nCon_BZ) )
	{
		AfxMessageBox(
		"DATA ERROR\nCOMPATIBILITY Problem\nNumber of Bezier Segments MisMatch!!\nTask Cancelled");
		return FALSE;
	}
	else
	{
		m_nSegs_S			= nBezSeg;				
		m_nMaxPatchCNodes_S	= nCon_BZ;
	}	
	//////////////////////////////////////////////////////////// Output Compatibility
	if(!IsCompat_OutputInfo(pCurveList,pLatchList) ) // ElPerSegList etc
	{
		AfxMessageBox(
		"DATA ERROR\nCOMPATIBILITY Problem\nNumber of Elements MisMatch!!\nTask Cancelled");
		return FALSE;
	}
	//////////////////////////////////////////////// Process Output_S
	CDrCurve* pCurve = (CDrCurve*)pCurveList->GetHead();
	SetPatchOutputDataFromCurve(pCurve,1/*nDir*/);
	//////////
	return TRUE;
}

BOOL CMP_CooP4::AreCurvesCompatible_V(CDListMgr* pCurveList,CList<CURVELATCH,CURVELATCH>* pLatchList,
											BOOL bClosed,int& nDim_S,int& nTopDegree,int& nCon_BZ)
{
	//////////////////////////////////////////////////////////// ALL Closed or Open
	if(!IsCompat_Closed(pCurveList,bClosed))
		return FALSE;
	else
		m_bClosed_T = bClosed;
	//////////////////////////////////////////////////////////// Segment Compatibility
	PreProcessCurvesControlInfo(pCurveList,nDim_S,nTopDegree); // TopDegree? etc
	////////////////////////////////////////////////////////////////
	m_nDim_T	= nDim_S;
	m_nOrder_T	= nTopDegree + 1;
	/////////////////////////////
	switch(m_nOrder_T)
	{
		case 2:
			m_CurveType_T = CP_LINEAR;
			break;
		case 3:
			m_CurveType_T = CP_QUADRATIC;
//			if() // Circle
//				m_CurveType_S = CP_CIRCLE;
			break;
		case 4:
			m_CurveType_T = CP_BSPLINE;
			if(m_nDim_T == 4)
				m_CurveType_T = CP_NURB;
			break;
		default:
			break;
	}
	//////////////////////////////////////////////////////////// Do it
	int nBezSeg;
	// Total Expected CNodes of EACH Curve
	if(!IsCompat_NumberOfCNodes(pCurveList,nTopDegree,nBezSeg,nCon_BZ) )
	{
		AfxMessageBox(
		"DATA ERROR\nCOMPATIBILITY Problem\nNumber of Bezier Segments MisMatch!!\nTask Cancelled");
		return FALSE;
	}
	else
	{
		m_nSegs_T			= nBezSeg;				
		m_nMaxPatchCNodes_T	= nCon_BZ;
	}	
	//////////////////////////////////////////////////////////// Output Compatibility
	if(!IsCompat_OutputInfo(pCurveList,pLatchList) ) // ElPerSegList etc
	{
		AfxMessageBox(
		"DATA ERROR\nCOMPATIBILITY Problem\nNumber of Elements MisMatch!!\nTask Cancelled");
		return FALSE;
	}
	//////////////////////////////////////////////// Process Output_S
	CDrCurve* pCurve = (CDrCurve*)pCurveList->GetHead();
	SetPatchOutputDataFromCurve(pCurve,2/*nDir*/);
	//////////
	return TRUE;
}

BOOL CMP_CooP4::IsCompat_Closed(CDListMgr* pCurveList,BOOL& bClosed)
{
	/////////////////////////////////////// Is ALL Closed or Open?
	CDListMgr* pList	= pCurveList;
	bClosed				= FALSE;
	int i = -1;
	//////////////////////////////////////////////////////////// Find Highest Degree
	for (POSITION pos = pList->GetFirstObjectPos();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			return FALSE;
   	 	///////////////////////////////////////////// IsClosed
		i++;
		if(i<=0) 
			bClosed = pCurve->IsClosed_S();
		else
		if(bClosed != pCurve->IsClosed_S())
			return FALSE;
		/////	
	}
	////////////
	return TRUE;
}

int CMP_CooP4::PreProcessCurvesControlInfo(CDListMgr* pCurveList,int& nDim_S,int& nTopDegree)
{
	/////////////////////////////////////// Rational?
	nDim_S	= 3;
	if(IsRational(pCurveList))
		nDim_S	= 4;
	/////////////////////////////////////// Find Highest Degree
	nTopDegree	= GetTopDegree(pCurveList);
	////////////
	return MA_OK;
}

BOOL CMP_CooP4::IsRational(CDListMgr* pCurveList)
{
	CDListMgr* pList = pCurveList;
	//////////////////////////////////////////////////////////// Find Highest Degree
	for (POSITION pos = pList->GetFirstObjectPos();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			continue;
   	 	///////////////////////////////////////////// Get Degree/Update
		int nDim = pCurve->GetnDim_S();
		if(4 == nDim)
			return TRUE;
		/////	
	}
	return FALSE;
}

int CMP_CooP4::GetTopDegree(CDListMgr* pCurveList)
{
	CDListMgr* pList = pCurveList;
	//////////////////////////////
	int nDegree=0,nDeg_C;
	//////////////////////////////////////////////////////////// Find Highest Degree
	for (POSITION pos = pList->GetFirstObjectPos();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			continue;
   	 	///////////////////////////////////////////// Get Degree/Update
		nDeg_C = (pCurve->GetOrder_S()) - 1;
		if(nDeg_C>nDegree)
			nDegree = nDeg_C;
		/////	
	}
	return nDegree;
}

BOOL CMP_CooP4::IsCompat_NumberOfCNodes(CDListMgr* pCurveList,int nTopDegree,
													int& nCurveSeg,int& nConBZ)
{
	// Check All Curves Have Same Number of CNodes after Elevation
	////////////////////////////////////////////////////////////// 
	CDListMgr*	pList = pCurveList;	// Curves making up Profile
	int nDeg_C,nElev,nCon;
	int nConBZOld;
//	BOOL bClosed;
	//////////////////////////////////////////////////////////// Total CNodes
	int k = 0;
	for (POSITION pos = pList->GetFirstObjectPos();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			return FALSE;	// error
		////
		k++;
		nConBZ		= 0;
   	 	///////////////////////////////////////////// Get Degree/Update
		nDeg_C		= (pCurve->GetOrder_S()) - 1;
		nElev		= nTopDegree - nDeg_C;	// How many Elevations	
		nCon 		= pCurve->GetMaxCNodes_S();
		nCurveSeg 	= pCurve->GetMaxBezSegments_S(); 
//		bClosed		= pCurve->IsClosed_S();
   		///////////////////////////////////////////// Update Total Control Nodes
   		nConBZ		= nCon;	
   		if(nElev>0)
   			nConBZ	+= nElev * nCurveSeg;	// nElev Cnodes per Curve Segment
		///////////////////////////////////////////// Check Compatibility
		if(k<=1)
			nConBZOld = nConBZ;	// first time
		else
		if(nConBZOld != nConBZ)	// InCompatible
			return FALSE;
	}
	///////////////
	return TRUE;

}

BOOL CMP_CooP4::IsCompat_OutputInfo(CDListMgr* pCurveList,
						CList<CURVELATCH,CURVELATCH>* pLatchList)
{
	POSITION pos,posL;
	BOOL bCompareBKward = FALSE;
	CURVELATCH LatchOld;
	CURVELATCH Latch;
	int nOut,nOutOld,nBezSegs;
	pINT	pNum;
	pINT	pNumOld;
	/////////////////////////////////////// Is ALL Output Info same?
	CDListMgr* pList	= pCurveList;
	int i= -1,j;
	//////////////////////////////////////////////////////////// Find Highest Degree
	for (pos = pList->GetFirstObjectPos(),posL = pLatchList->GetHeadPosition();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			return FALSE;
		Latch	= pLatchList->GetNext(posL);  
		nOut	= (int)pCurve->GetLongOutPts();
		pNum	= pCurve->GetNum_tPointer_S();
   	 	///////////////////////////////////////////// 
		i++;
		if(i<=0)
		{
			nBezSegs		= pCurve->GetMaxBezSegments_S();
			pNumOld			= pNum;
			LatchOld		= Latch;
			nOutOld			= nOut;
			/////////
			continue;
		}
		else
		{
			if(nOutOld	!= nOut)
				return FALSE;
			///////////////////////////////////////// SegmentWise
			bCompareBKward = (LatchOld == Latch)? FALSE:TRUE;
			///////////////////////////////////////////// go over the list
			if(bCompareBKward)
			{
				for (j=0;j<nBezSegs;j++)
				{
					////
					int nElems		= pNum[(nBezSegs-1)-j];
					///////
					int nElemsOld	= pNumOld[j];
					///////////////////////////////////////////////// same
					if(nElemsOld != nElems)
						return FALSE;
				}
			}
			else
			{
				for (j=0;j<nBezSegs;j++)
				{
					////
					int nElems		= pNum[j];
					///////
					int nElemsOld	= pNumOld[j];
					///////////////////////////////////////////////// same
					if(nElemsOld != nElems)
						return FALSE;
				}
			}
		}
	}
	////////////
	return TRUE;
/*
	POSITION pos,posL;
	BOOL bCompareBKward = FALSE;
	CURVELATCH LatchOld;
	CURVELATCH Latch;
	/////////////////////////////////////// Is ALL Output Info same?
	CDListMgr* pList	= pCurveList;
	CList<int,int>*	pElperSegList;	 	
	CList<int,int>*	pElperSegListOld;	 	
	int i= -1,j;
	//////////////////////////////////////////////////////////// Find Highest Degree
	for (pos = pList->GetFirstObjectPos(),posL = pLatchList->GetHeadPosition();pos !=NULL;)
	{
		CDrCurve* pCurve = (CDrCurve*)pList->GetNextObject(pos);
		if(!pCurve)
			return FALSE;
		Latch			= pLatchList->GetNext(posL);  
		pElperSegList	= pCurve->GetElperSegList_S();
   	 	///////////////////////////////////////////// ElperSegList
		i++;
		if(i<=0)
		{
			pElperSegListOld	= pElperSegList;
			LatchOld			= Latch;
			///
			if(pElperSegList->IsEmpty())	// must have some Elems
				return FALSE;
			else
				continue;
		}
		else
		{
			///////////////////////////////////////////// same count of indices?
			if(pElperSegList->GetCount() != pElperSegListOld->GetCount())
				return FALSE;
			/////////////////////////////////////////////////
			bCompareBKward = (LatchOld == Latch)? FALSE:TRUE;
			///////////////////////////////////////////// go over the list
			if(bCompareBKward)
			{
				j = -1;
				for (POSITION posI = pElperSegList->GetTailPosition( );posI !=NULL;)
				{
					j++;
					////
					int nElems = pElperSegList->GetPrev(posI);
					///////
					POSITION posOld = pElperSegListOld->FindIndex(j);
					int nElemsOld = pElperSegList->GetAt(posOld);
					///////////////////////////////////////////////// same
					if(nElemsOld != nElems)
						return FALSE;
				}
			}
			else
			{
				j = -1;
				for (POSITION posI = pElperSegList->GetHeadPosition( );posI !=NULL;)
				{
					j++;
					////
					int nElems = pElperSegList->GetNext(posI);
					///////
					POSITION posOld = pElperSegListOld->FindIndex(j);
					int nElemsOld = pElperSegList->GetAt(posOld);
					///////////////////////////////////////////////// same
					if(nElemsOld != nElems)
						return FALSE;
				}
			}
		}
	}
*/
	////////////
	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////////////
int CMP_CooP4::ProcessCurves(CDListMgr* pCurveList,CList<CURVELATCH,CURVELATCH>* pLatchList,
							 pWORLD pCon_BZ,pDOUBLE pWts_BZ,int nCon_BZ,
							 int nCon_BZTot,int nDegree,int nDim)
{
	int nConActual = 0;
	/////////////////////////////////////////////////////////////// Degree Elevate 
	nConActual = Elevate_PatCurves(pCurveList,pLatchList,
								pCon_BZ, pWts_BZ, nDegree, nDim);
	/////////////////////////
	if(nConActual != nCon_BZTot)
	{
		AfxMessageBox("Internal Problem:\nCMP_CooP4::Elevate_Profile");
		return -1;
	}									
	/////////
	return 0;
}

int CMP_CooP4::Elevate_PatCurves(CDListMgr* pCurveList,CList<CURVELATCH,CURVELATCH>* pLatchList,
											pWORLD pCon_BZ, pDOUBLE pWts_BZ,int nDegree, int nDim)
{

	/////////////////////////////////// 
	int m,nDegOld,nElev,nSeg_BZ,nConOld,nConNew,nConTot=0,nBegNew=0;
	/////////////////////////////////////// 	
	int nCount=0; 
  	////////////////////////////////////////// memory	
	pWORLD		pConOld;
	pDOUBLE		pWtsOld;
	pWORLD		pConNew;
	pDOUBLE		pWtsNew;
	POSITION	posCurve;
	POSITION	posLatch;	
	//////////////////////////////////////////////////////////// Controls
	for (	posCurve = pCurveList->GetFirstObjectPos(),
			posLatch = pLatchList->GetHeadPosition();posCurve !=NULL;)
	{
		CDrCurve* pCurve	= (CDrCurve*)pCurveList->GetNext(posCurve);
		CURVELATCH cLatch	= pLatchList->GetNext(posLatch);
		BOOL bClosed		= pCurve->IsClosed_S();
		/////////
		if(!pCurve)
			continue;
		CDegElevate DegElevate(bClosed);
		/////////////////////////////////////// GetControl Nodes
		nConOld 	= pCurve->GetMaxCNodes_S();
		nDegOld		= (pCurve->GetOrder_S()) - 1;
		nElev		= nDegree - nDegOld;	// How many Elevations	
		nSeg_BZ 	= pCurve->GetMaxBezSegments_S(); 
   		/////////////////////////////////////// 
   		nConNew		= nConOld;	
   		if(nElev>0)
   			nConNew	+= nElev * nSeg_BZ;	// nElev Cnodes per Curve Segment 
   		////////////////////////////////////////// memory	
		pConOld 	= new WORLD [nConOld];
		pWtsOld 	= new double[nConOld];
		pConNew 	= new WORLD [nConNew];
		pWtsNew 	= new double[nConNew];
		////////////////////////////////////////// get Old 
		GetCNodeCoords_N_Wts(pCurve, cLatch, pConOld, pWtsOld);
   	 	///////////////////////////////// 
		int nConActual = 
				DegElevate.Elevate_Curve(pConOld, pWtsOld, nDegOld, nElev, pConNew, pWtsNew,
								nSeg_BZ, nDim);
   		////////////////////////////////////////// Free memory
		delete [] pConOld;
		delete [] pWtsOld;
		//////////////////
		if(nConActual != nConNew)
		{
			AfxMessageBox("Internal Problem:\nCMP_CooP4::Elevate_Profile");
			return -1;
		}									
		/////////////////////////////////////// save
		for(m=0;m<nConNew;m++)	
		{
			nConTot++;
			///////////////
			pCon_BZ[nBegNew+m].x = pConNew[m].x; 	
			pCon_BZ[nBegNew+m].y = pConNew[m].y; 	
			pCon_BZ[nBegNew+m].z = pConNew[m].z; 	
			pWts_BZ[nBegNew+m]   = pWtsNew[m]; 	
			///////////////////////////////////
		}
		nBegNew += nConNew;									
   		////////////////////////////////////////// Free memory
		delete [] pConNew;
		delete [] pWtsNew;
		////////////////////////////////////////// 
	}
	//////////////////
	return nConTot;
}

int CMP_CooP4::GetCNodeCoords_N_Wts(CDrCurve* pCurve, CURVELATCH cLatch, 
									pWORLD pConOld, pDOUBLE pWtsOld)
{
	CDListMgr* pList	= pCurve->GetCNodeList();
	pDOUBLE pWts		= pCurve->GetpWts_BZ_S();
	int nCon_BZ			= pCurve->GetMaxCNodes_S();
	int nCon_IndexMax	= nCon_BZ -1;
	/////////////////////////////////////////////////////////////// Coords 
	int j=-1;
	if(!pList->IsEmpty())
	{
		////////
		for (POSITION pos = pList->GetFirstObjectPos();pos !=NULL;)
		{
			CDrNode* pNode = (CDrNode*)pList->GetNextObject(pos);
			///////////////////////////////////////
			if(cLatch == CL_FORWARD)
				pConOld[++j] = *(pNode->GetLocalPos());
			else
			if(cLatch == CL_BACKWARD)
				pConOld[nCon_IndexMax - (++j) ] = *(pNode->GetLocalPos());
			//////////////////////////////////
		}
	}
	/////////////////////////////////////////////////////////////// Wts
	for(j=0;j<nCon_BZ;j++)
	{
		if(cLatch == CL_FORWARD)
			pWtsOld[j] = pWts[j];
		else
		if(cLatch == CL_BACKWARD)
			pWtsOld[nCon_IndexMax - j] = pWts[j];
	}
	/////////
	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////
int CMP_CooP4::DoNetCoons(
					pWORLD pConBZ_S,pDOUBLE pWtsBZ_S,int nConBZ_S,
					pWORLD pConBZ_T,pDOUBLE pWtsBZ_T,int nConBZ_T,
					pWORLD pPatCons,pDOUBLE pPatWts,int nTotOut)
{
	// NetCoons
	////////////////////////////////////////////// generate Patch Pts
	CPA_CoonP	PA_CoonP;
	int nOutActual	= PA_CoonP.CoonCurves
			(
				(short)nConBZ_S,	//	number of input Control points in S-dir
				(short)nConBZ_T,	//	number of input Control points in T-dir
				pConBZ_S,			//	input data point for Curve 1
		      	pWtsBZ_S,			//	input data Weight for Curve 1 
				pConBZ_T,			//	input data point for Curve 2
		      	pWtsBZ_T,			//	input data Weight for Curve 2 
				pConBZ_S+nConBZ_S,	//	input data point for Curve 3
		      	pWtsBZ_S+nConBZ_S,	//	input data Weight for Curve 3 
				pConBZ_T+nConBZ_T,	//	input data point for Curve 2
		      	pWtsBZ_T+nConBZ_T,	//	input data Weight for Curve 2 
				pPatCons,			//	Output ControlPts array
				pPatWts				//	Output Wts array
			);	  
	////////////////////////////	
	if(nOutActual != nTotOut)
	{
		AfxMessageBox("Internal ERROR:\nint CMP_CooP4::GenerateCNodes\nnOutActual != nTotOut");
		return MA_ERROR;
	}
	else
		return MA_OK;
}


int CMP_CooP4::CreateSavePatCNodes_N_Wts(CDrPatch* pDrPatch,pWORLD pConBZ,pDOUBLE pWts_BZ,
																	int nCN_S,int nCN_T)
{
	CDListMgr*	pCNList = pDrPatch->GetCNodeList();
	//////////////////////////////////////////////////////
	WORLD		LocalPos;
	CString		PatchID;
    CDrNode* 	pAddNode;
	int s,t,j;
	///////////////////////////////////////////// Name
	PatchID	= pDrPatch->GetObjectID();
	////////////////////////////////////
	for (t = 0; t<nCN_T; t++)
	{
		for (s = 0; s<nCN_S; s++)
		{
   			///////////////////////////////////////// CREATE	
		    //////////////////////////////////// Name
			CString* pNid = new CString;
			char* buf = pNid->GetBuffer(BUFF_SIZE);
		    sprintf(buf,"%s_%d%d",PatchID,s,t);
			////////////////////////////////////
			j = t*nCN_S + s;
			////////////////////////////		
			LocalPos.x	= (pConBZ+j)->x;
			LocalPos.y	= (pConBZ+j)->y;
			LocalPos.z	= (pConBZ+j)->z;
			///////////////////////////////////// in THE List 
			pAddNode = PostNode(*pNid,LEVEL_KIDDO,LocalPos,TRUE);	// Create DrCNode
			delete pNid;
			//////////////
			if(!pAddNode)	
				return -1;
			///////////////////////////////////// in PATCH 	
   			pCNList->InsertObject(pAddNode); //CNodeList 
		}				
	}
	////////////////////////////////////////////////////////// save Wts
	pDrPatch->SetMemInWts(pWts_BZ);
	/////////////
	return MA_OK;
}

int CMP_CooP4::SetInfoForDataBase(CDrPatch* pDrObject,
					CDListMgr* pCurveList_U,CDListMgr* pCurveList_V,
					CList<CURVELATCH,CURVELATCH>* pCurveLatchList_U,
					CList<CURVELATCH,CURVELATCH>* pCurveLatchList_V)
{
	pDrObject->SetDirty(TRUE);
	///////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument();
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	///////////////////////////////////////////////
	CDrPen*	pDrPen			= (CDrPen*)pObjectMgr->GetSpecObject(DRPEN);
	CLayer* pLayer			= (CLayer*)pObjectMgr->GetSpecObject(LAYER); 
	//////////////////////////////////////////////////// Update Current DrObject
    pDrObject->SetObjectType((int)PATCH);
    pDrObject->SetElemType((int)GENR_OBJECT);          // globals
    pDrObject->SetLevelType((int)LEVEL_GRAPA);          // globals
	pDrObject->SetPatchProc(PP_COONSQUAD);
	pDrObject->SetPatchType(PA_TENSOR);
	pDrObject->SetPatSubType(PS_QUADRILAT);
    //////////////////////////////
	pDrObject->SetObjectID(m_PatchID);
	//////////////////////////////////
	pDrObject->SetGenBCurve(m_bGenBCur);
	///////////////////////////////////////////////////////////////////
	pDrObject->SetPrimaryDir(3);// both
	/////////////////////////////////////
	SetInfoForDataBase_1(pDrObject,	pCurveList_U,pCurveLatchList_U,
									pCurveList_V,pCurveLatchList_V);
	/////////////////////////////////////////////////////////
	m_nOut = (long)m_nOut_S * (long)m_nOut_T;
	pDrObject->SetLongOutPts(m_nOut);			// m_nOut	
	//////////////////////////////////////////////////
	// call to NumberOfPatches() Overrides:	//
	//		m_nOut_S,m_nOut_T,m_nOut				//
	////////////////////////////////////////////////// 
	int nOutTotal = pDrObject->NumberOfPatches();
	if(nOutTotal != (int)m_nOut)
	{
		AfxMessageBox("Internal Problem:\nCMP_CooP4::SetInfoForDataBase\nm_nOut Mismatch!");
		return MA_ERROR;
	}
	////////////////////////////////////////////////////////////////////////////////	
	pDrObject->SetPenInfo(pDrPen->GetWidth(),pDrPen->GetColor(),pDrPen->GetStyle());
	pDrObject->SetLayer(pLayer->GetCurrentLayer());
	////////////////////////////////////// LOCAL 3DBounds using
										// ConVexHull Property
	pDrObject->Calc_3DBoundsLocal();
	///////
	return MA_OK;
}


void CMP_CooP4::SetInfoForDataBase_1(CDrPatch* pDrObject,
					CDListMgr* pCurveList_U,CList<CURVELATCH,CURVELATCH>* pCurveLatchList_U,
					CDListMgr* pCurveList_V,CList<CURVELATCH,CURVELATCH>* pCurveLatchList_V)
{
	////////////////////////////////////////////////////////// CurveList
	CDListMgr* pList; 
	POSITION pos;
	CDrCurve* pCurve;
	///////////////////////////////////////////////// Reciprocate
	pList = pDrObject->GetCurveList(); 
	pList->RemoveAll();
	pList->InsertObject(pCurveList_U->GetHead());	// Curve 1
	pList->InsertObject(pCurveList_V->GetHead());	// Curve 2
	pList->InsertObject(pCurveList_U->GetTail());	// Curve 3
	pList->InsertObject(pCurveList_V->GetTail());	// Curve 4
	/////
	for (pos = pList->GetFirstObjectPos();pos !=NULL;)
	{
		pCurve 	= (CDrCurve*)pList->GetNextObject(pos);
		/////////////////////////////////////////// does exist already?
		int index = pCurve->GetPatchList()->GetObjectIndex(pDrObject);
		if(index<0)
			pCurve->GetPatchList()->InsertObject(pDrObject);
	}
	///////////////////////////////////////////////// Save
	pList = pDrObject->GetCurveList_U(); 
	pList->RemoveAll();
	pList->AddTail(pCurveList_U);
	///////////////////////////////////////////////// Save
	pList = pDrObject->GetCurveList_V(); 
	pList->RemoveAll();
	pList->AddTail(pCurveList_V);
	/////////////////////////////////////////////////////////////////
	pDrObject->GetCurveLatchList_U()->RemoveAll();
	pDrObject->GetCurveLatchList_U()->AddTail(pCurveLatchList_U);
	pDrObject->GetCurveLatchList_V()->RemoveAll();
	pDrObject->GetCurveLatchList_V()->AddTail(pCurveLatchList_V);
	///////////////////////////////////////////////////////////////// All Other
	pDrObject->SetRatio_S(m_Ratio_S);					
	pDrObject->SetRatio_T(m_Ratio_T);					
	pDrObject->SetUniform_S(m_bUnifOT_S);		// Output Distribution:
	pDrObject->SetUniform_T(m_bUnifOT_T);		// Output Distribution:
//	pDrObject->SetSegmentCount_S(m_nMaxOSeg_S); 	// for Old Compatibility
//	pDrObject->SetSegmentCount_T(m_nMaxOSeg_T); 	// for Old Compatibility
	pDrObject->SetMaxOutSeg_S(m_nMaxOSeg_S);	// Number of Output Segments
	pDrObject->SetMaxOutSeg_T(m_nMaxOSeg_T);	// Number of Output Segments
//?
	pDrObject->SetMaxOutPts_S(m_nOut_S);
	pDrObject->SetMaxOutPts_T(m_nOut_T);
	pDrObject->SetOut_S(m_nOut_S);
	pDrObject->SetOut_T(m_nOut_T);
	//////////////////////////////////////////
	pDrObject->SetCurveType_S(m_CurveType_S);
	pDrObject->SetCurveType_T(m_CurveType_T);
	pDrObject->SetMaxCNodes_S(m_nMaxPatchCNodes_S);
	pDrObject->SetMaxCNodes_T(m_nMaxPatchCNodes_T);
	///////////////////////////////////////////////////
//	pDrObject->SetSegmentCount_S(m_nSegs_S);	
//	pDrObject->SetSegmentCount_T(m_nSegs_T); 
	pDrObject->SetMaxBezSegments_S(m_nSegs_S);	
	pDrObject->SetMaxBezSegments_T(m_nSegs_T); 
	pDrObject->SetClosed_S(m_bClosed_S);
	pDrObject->SetClosed_T(m_bClosed_T);
	pDrObject->SetOut_S(m_nOut_S);	
	pDrObject->SetOut_T(m_nOut_T);
	pDrObject->SetOrder_S(m_nOrder_S);
	pDrObject->SetOrder_T(m_nOrder_T);
//	pDrObject->SetnDim_S(m_nDim_S);
//	pDrObject->SetnDim_T(m_nDim_T);
	pDrObject->SetnDim_S(4);	// ALWAYS RATIONAL
	pDrObject->SetnDim_T(4);	// ALWAYS RATIONAL
	///////////////////////////////////////////////////////// for now
	pDrObject->SetNum_tPointer_S(m_pNum_t_S);			// Number of Outputs for each Output Segment
	pDrObject->SetNum_tPointer_T(m_pNum_t_T);			// Number of Outputs for each Output Segment
	//////////////////////////////////////////////////////////////////////
	pDrObject->SetDis_tPointer_S(m_pDis_t_S);			// s-distribution
	pDrObject->SetDis_tPointer_T(m_pDis_t_T);			// t-distribution
	////////////////
	return;
}
///////////////////////////////////////////////////////////////////////////////////////////
int CMP_CooP4::LatticeCurves_U(CDrPatch* pDrPatch,int nOrder_T,BOOL bClosed_T,int nSegBZ_T,
													int nConBZ_S,CDrCurve* pCurOriginal)
{
	/////////////////////
	// Create LatticeCurves_U at Bez. JnPts. Only
	/////////////////////////////////////////////
	// Hints: geteach set of Cnodes & Wts COL from pDrPatch and create a NURB Curve
	// with other similar properties as pCurveOriginal
	// Create New INodes
	//////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	CDListMgr*	pList;
	///////////////////
	int i;
	int nActiveIndex;
	CDrCurve* pCurve;
	CString	ID;
	CString PatchID = pDrPatch->GetObjectID();
	//
	int nDegree_S = pCurOriginal->GetOrder_S() - 1;
	int nDegree_T = nOrder_T - 1;
	///////////////////
	pObjectMgr->SetActiveObjectType(CURVE);
	//////////////////////////////////////////////////////// Loop Over Bez. Pts. on Curves
	int nCurves = (bClosed_T)?nSegBZ_T:nSegBZ_T+1;
	for(i=0;i<nCurves;i++)
	{
		////////////////////////////////////////////////////// Add to DataBase
		pObjectMgr->SetObjInfoID(ID,CURVE);
//		ID += "_" + PatchID;
		///////////////////////////////////////// delete & Add
		pList = pObjectMgr->GetObjectList(CURVE);
		nActiveIndex = pList->GetObjectIndex(CURVE, ID);
		if(nActiveIndex>=0)
		{
			pObjectMgr->DeleteFromDataBase(nActiveIndex, CURVE);
			pCurve = (CDrCurve*)NULL;
		}
		pCurve	= (CDrCurve*)(pObjectMgr->AddToDataBase(ID,nActiveIndex,CURVE));
		////////////////////////
		pCurve->SetObjectID(ID);
		////////////////////////////////////
		pCurve->SetShow(FALSE);	// not quite ready
		//////////////////////////////////////////////////////////////////////// CNODES & WTS
		// Fill CNodeList w/ CNodes created from CNodes of Patch  Col
		CDListMgr* pCNodeList = pCurve->GetCNodeList();
		pCNodeList->RemoveAll();
		pDOUBLE pWts_DT = new double[nConBZ_S]; 
		//////////
		// CreateFillCNodeslist/Wts
		CreateFillCNodeList_N_Wts_S(pDrPatch,i,nDegree_T,nConBZ_S,pCNodeList,pWts_DT);
		//////////////////////////////////////////////////////// Setup Weights
//		ExtractWts_S(pDrPatch,i,nDegree_T,nConBZ_S,pWts_DT);
		// save
		pCurve->SetWtType_S(WT_AUTO);	// AutoType
		pCurve->SetpWts_BZ_S(pWts_DT);	// Rational Weights
										// copy will be deleted when
										// Curve is deleted
		///////////////////////////////////////// ReParametrize Bez Wts, in case
		ReParametrizeBezWeightsToStdForm(pCurve);
		///////////////////////////////////////////////////////////////////////// INODES 
		// Fill INodeList w/ INodes of XSection Curve
		CDListMgr INodeList;
		INodeList.RemoveAll();
		int nINode = pCurOriginal->GetINodeList()->GetCount(); // Original Curve Compatible
		// Create/Fill INodes as Input
		CreateFillINodeList_S(pDrPatch,i,nINode,nDegree_S,nDegree_T,nConBZ_S,&INodeList);
		pCurve->GetINodeList()->AddTail(&INodeList);	// copy
		///////////////////////////////////////////////////////////////////////// KNOTS
		CDListMgr* pINList = pCurve->GetINodeList();
		int nData = pINList->GetCount();
		pWORLD inData = new WORLD[nData];
		/////
		SetUpINodes(pINList,inData,nData);
		/////
		m_nKnots_S = pCurve->GetnKnots_S();
		pDOUBLE m_pKnot_S = new double[m_nKnots_S];	// will be deleted in DrCurve
		/////
		m_KnotType_S = KN_AUTO;	// chordlength
		SetupKnots(inData,m_KnotType_S,m_pKnot_S,m_nKnots_S);
		///////////////////////////////////////////////////// Save
		pCurve->SetpKnots_S(m_pKnot_S);	// pointer
		//////////////////////////////////////////
		delete [] inData;
		///////////////////////////////////////////////////////////////////////// END CONDS
		pCurve->SetBCL_S(pCurOriginal->GetBCL_S());
		pCurve->SetBCR_S(pCurOriginal->GetBCR_S());
		pCurve->SetTanL_S(pCurOriginal->GetTanL_S());
		pCurve->SetTanR_S(pCurOriginal->GetTanR_S());
		///////////////////////////////////////////////////////////////////////// ElSegList
		pCurve->GetElperSegList_S()->AddTail(pCurOriginal->GetElperSegList_S());
		///////////////////////////////////////////////////////////////////////// ALL OTHER
		SetDataFromCurve_Lattice(pCurOriginal);
		///////////////////////////////////////////////////////////////////////// FINALLY Save
		SetInfoDataBase_LatticeCurve(pCurve);
		///////////////////////////////////////////////////////////////////////// Change Color
		pCurve->SetPenInfo(0,MAGENTA,PS_SOLID);
		pCurve->SetShow(TRUE);
		/////////////////////////////////
//		pCurveList->InsertObject(pCurve);
	}
	//////////////
	return MA_OK;
}

int CMP_CooP4::CreateFillINodeList_S(CDrPatch* pDrPatch,int iCurve_U,int nINode_U,
					int nDegree_S,int nDegree_T,int nConBZ_S,CDListMgr* pINodeList)
{
	int nResult;
	//////////////////////////////////////
	CDListMgr* pCNList	= pDrPatch->GetCNodeList();
	CString PatchID		= pDrPatch->GetObjectID();
	//////////////////////
	nResult =  PackINodeList_S(PatchID,pCNList,iCurve_U,nINode_U,nDegree_S,nDegree_T,pINodeList,
																					nConBZ_S);
	////////////
	if(nResult == MA_ERROR)
		return MA_ERROR;
	//////////////
	return MA_OK;
}

int CMP_CooP4::PackINodeList_S(CString& PatchID,CDListMgr* pCNodeList,int iCurve_U,int nINode,
									 int nDeg_U,int nDeg_V,CDListMgr* pINodeList,int nConBZ_S)
{
	// Packs Jn. Pts. of CNodeList as INODES
	////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	///////////////////
	int			i,index,iCol;
	CDrNode*	pCNode;
	CDrNode*	pINode;
	WORLD		wLocalPos;
	CString		ID;
	CDrLabel*	pLabel;
	int			nNodeIndex,nLabelIndex;
	////////////////////////
	pINodeList->RemoveAll();
	////////////////////////
	iCol	= (iCurve_U * nDeg_V /*= iCol*/) * nConBZ_S;
	for(i=0;i<nINode;i++)
	{
		index	= iCol + i * nDeg_U; 
		pCNode	= (CDrNode*)pCNodeList->GetObject(index);
		/////
		if(pCNode)
		{
			//////////////////////////////// Create an INode
			pObjectMgr->SetObjInfoID(ID,INODE);
//			ID += "_" + PatchID;
			wLocalPos = *(pCNode->GetLocalPos());
			/////////////////////////// Create Anyway
			nNodeIndex = -12345;
			pINode = CreateNode(ID,pLabel,wLocalPos,FALSE/*Not CNode*/,TRUE,
									nNodeIndex,nLabelIndex,LEVEL_GRAPA);
			//////////////////////////////////
			if(!pINode)	// Create DrCNode
			return MA_ERROR;
			///////////////////////////////////
			pINodeList->InsertObject(pINode);
		}
	}
	/////////////
	return MA_OK;
}

int CMP_CooP4::CreateFillCNodeList_N_Wts_S(CDrPatch* pDrPatch,int iCurve_U,int nDegree_T,
									int nConBZ_S,CDListMgr* pCNodeList,pDOUBLE pWts)
{
	int nResult;
	//////////////////////////////////////
	CDListMgr* pPatCNList	= pDrPatch->GetCNodeList();
	pDOUBLE pPatWts			= pDrPatch->GetMemInWts();
	CString PatchID			= pDrPatch->GetObjectID();
	//////////////////////
	nResult =  PackCNodeList_N_Wts_S(PatchID,pPatCNList,pPatWts,iCurve_U,nDegree_T,nConBZ_S,
																	pCNodeList,pWts);
	////////////
	if(nResult == MA_ERROR)
		return MA_ERROR;
	//////////////
	return MA_OK;
}

int CMP_CooP4::PackCNodeList_N_Wts_S(CString& PatchID,CDListMgr* pPatCNodeList,pDOUBLE pPatWts,
				int iCurve_U,int nDeg_V,int nConBZ_S,CDListMgr* pCNodeList,pDOUBLE pWts)
{
	// Create All CNodes corresponding To XSec Curve
	// ( Extracted From Patch CNodes at Jn. Pts. along T-direction) 
	//////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	///////////////////
	int			i,index,iCol;
	CDrNode*	pCNode;
	double		Wts;
	WORLD		wLocalPos;
	CDrNode*	pAddNode;
	////////////////////////
	pCNodeList->RemoveAll();
	////////////////////////
	iCol	= (iCurve_U * nDeg_V) * nConBZ_S;
	for(i=0;i<nConBZ_S;i++)
	{
		index = iCol + i;	// 
		pCNode	= (CDrNode*)pPatCNodeList->GetObject(index);
		Wts		= pPatWts[index];
		/////
		if(pCNode)
		{
			//////////////////////////////////// Coords
			wLocalPos = *(pCNode->GetLocalPos());
		    //////////////////////////////////// Name
			CString* pNid = new CString;
			char* buf = pNid->GetBuffer(BUFF_SIZE);
		    sprintf(buf,"%s_%d_%d","C",i,iCol);
			///////////////////////////////////// in THE List 
			pAddNode = PostNode(*pNid,LEVEL_KIDDO,wLocalPos,FALSE);	// Create DrNode
			delete pNid;
			/////////////
			if(!pAddNode)	// Create DrCNode
				return MA_ERROR;
			///////////////////////////////////// in Curve 	
			pCNodeList->InsertObject(pAddNode); //CNodeList
			/////////////////////////////////////////////// Save Wts
			pWts[i] = Wts;
		}
		else
			return MA_ERROR;
	}
	/////////////
	return MA_OK;
}

///////////////////////////////////////////////////////////////////////////////////////////
int CMP_CooP4::LatticeCurves_V(CDrPatch* pDrPatch,int nOrder_S,BOOL bClosed_S,int nSegBZ_S,
										int nConBZ_S,int nConBZ_T,CDrCurve* pCurOriginal)
{
	/////////////////////
	// Create LatticeCurves_V at Bez. JnPts. Only
	/////////////////////////////////////////////
	// Hints: geteach set of Cnodes & Wts COL from pDrPatch and create a NURB Curve
	// with other similar properties as pCurveOriginal
	// Create New INodes
	//////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	CDListMgr*	pList;
	///////////////////
	int i;
	int nActiveIndex;
	CDrCurve* pCurve;
	CString	ID;
	CString PatchID = pDrPatch->GetObjectID();
	//
	int nDegree_T = pCurOriginal->GetOrder_S() - 1;
	int nDegree_S = nOrder_S - 1;
	///////////////////
	pObjectMgr->SetActiveObjectType(CURVE);
	//////////////////////////////////////////////////////// Loop Over Bez. Pts. on Curves
	int nCurves = (bClosed_S)?nSegBZ_S:nSegBZ_S+1;
	for(i=0;i<nCurves;i++)
	{
		////////////////////////////////////////////////////// Add to DataBase
		pObjectMgr->SetObjInfoID(ID,CURVE);
//		ID += "_" + PatchID;
		///////////////////////////////////////// delete & Add
		pList = pObjectMgr->GetObjectList(CURVE);
		nActiveIndex = pList->GetObjectIndex(CURVE, ID);
		if(nActiveIndex>=0)
		{
			pObjectMgr->DeleteFromDataBase(nActiveIndex, CURVE);
			pCurve = (CDrCurve*)NULL;
		}
		pCurve	= (CDrCurve*)(pObjectMgr->AddToDataBase(ID,nActiveIndex,CURVE));
		////////////////////////
		pCurve->SetObjectID(ID);
		////////////////////////////////////
		pCurve->SetShow(FALSE);	// not quite ready
		//////////////////////////////////////////////////////////////////////// CNODES & WTS
		// Fill CNodeList w/ CNodes created from CNodes of Patch  Row
		CDListMgr* pCNodeList = pCurve->GetCNodeList();
		pCNodeList->RemoveAll();
		pDOUBLE pWts_DT = new double[nConBZ_T]; 
		//////////
		// CreateFillCNodeslist/Wts
		CreateFillCNodeList_N_Wts_T(pDrPatch,i,nDegree_S,nConBZ_S,nConBZ_T,pCNodeList,pWts_DT);
		//////////////////////////////////////////////////////// Setup Weights
		// save
		pCurve->SetWtType_S(WT_AUTO);	// UserType
		pCurve->SetpWts_BZ_S(pWts_DT);	// Rational Weights
										// copy will be deleted when
										// Curve is deleted
		///////////////////////////////////////// ReParametrize Bez Wts, in case
		ReParametrizeBezWeightsToStdForm(pCurve);
		///////////////////////////////////////////////////////////////////////// INODES 
		// Fill INodeList w/ INodes of XSection Curve
		CDListMgr INodeList;
		INodeList.RemoveAll();
		int nINode = pCurOriginal->GetINodeList()->GetCount(); // Original Curve Compatible
		// Create/Fill INodes as Input
		CreateFillINodeList_T(pDrPatch,i,nINode,nDegree_S,nDegree_T,nConBZ_S,&INodeList);
		pCurve->GetINodeList()->AddTail(&INodeList);	// copy
		///////////////////////////////////////////////////////////////////////// KNOTS
		CDListMgr* pINList = pCurve->GetINodeList();
		int nData = pINList->GetCount();
		pWORLD inData = new WORLD[nData];
		/////
		SetUpINodes(pINList,inData,nData);
		/////
		m_nKnots_S = pCurve->GetnKnots_S();
		pDOUBLE m_pKnot_S = new double[m_nKnots_S];	// will be deleted in DrCurve
		/////
		m_KnotType_S = KN_AUTO;	// chordlength
		SetupKnots(inData,m_KnotType_S,m_pKnot_S,m_nKnots_S);
		///////////////////////////////////////////////////// Save
		pCurve->SetpKnots_S(m_pKnot_S);	// pointer
		//////////////////////////////////////////
		delete [] inData;
		///////////////////////////////////////////////////////////////////////// END CONDS
		pCurve->SetBCL_S(pCurOriginal->GetBCL_S());
		pCurve->SetBCR_S(pCurOriginal->GetBCR_S());
		pCurve->SetTanL_S(pCurOriginal->GetTanL_S());
		pCurve->SetTanR_S(pCurOriginal->GetTanR_S());
		///////////////////////////////////////////////////////////////////////// ElSegList
		pCurve->GetElperSegList_S()->AddTail(pCurOriginal->GetElperSegList_S());
		///////////////////////////////////////////////////////////////////////// ALL OTHER
		SetDataFromCurve_Lattice(pCurOriginal);
		///////////////////////////////////////////////////////////////////////// FINALLY Save
		SetInfoDataBase_LatticeCurve(pCurve);
		///////////////////////////////////////////////////////////////////////// Change Color
		pCurve->SetPenInfo(0,MAGENTA,PS_SOLID);
		pCurve->SetShow(TRUE);
		/////////////////////////////////
//		pCurveList->InsertObject(pCurve);
	}
	//////////////
	return MA_OK;
}

int CMP_CooP4::CreateFillCNodeList_N_Wts_T(CDrPatch* pDrPatch,int iCurve_V,int nDegree_S,
						int nConBZ_S,int nConBZ_T,CDListMgr* pCNodeList,pDOUBLE pWts)
{
	int nResult;
	//////////////////////////////////////
	CDListMgr* pPatCNList	= pDrPatch->GetCNodeList();
	pDOUBLE pPatWts			= pDrPatch->GetMemInWts();
	CString PatchID			= pDrPatch->GetObjectID();
	//////////////////////
	nResult =  PackCNodeList_N_Wts_T(PatchID,pPatCNList,pPatWts,iCurve_V,nDegree_S,
												nConBZ_S,nConBZ_T,pCNodeList,pWts);
	////////////
	if(nResult == MA_ERROR)
		return MA_ERROR;
	//////////////
	return MA_OK;
}

int CMP_CooP4::PackCNodeList_N_Wts_T(CString& PatchID,CDListMgr* pPatCNodeList,pDOUBLE pPatWts,
			int iCurve_V,int nDeg_U,int nConBZ_S,int nConBZ_T,CDListMgr* pCNodeList,pDOUBLE pWts)
{
	// Create All CNodes corresponding To XSec Curve
	// ( Extracted From Patch CNodes at Jn. Pts. along T-direction) 
	//////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	///////////////////
	int			i,index,iRow;
	CDrNode*	pCNode;
	double		Wts;
	WORLD		wLocalPos;
	CDrNode*	pAddNode;
	////////////////////////
	pCNodeList->RemoveAll();
	////////////////////////
	iRow	= iCurve_V * nDeg_U /*= iRow*/;
	for(i=0;i<nConBZ_T;i++)
	{
		index	= iRow + i * nConBZ_S; 
		pCNode	= (CDrNode*)pPatCNodeList->GetObject(index);
		Wts		= pPatWts[index];
		/////
		if(pCNode)
		{
			//////////////////////////////////// Coords
			wLocalPos = *(pCNode->GetLocalPos());
		    //////////////////////////////////// Name
			CString* pNid = new CString;
			char* buf = pNid->GetBuffer(BUFF_SIZE);
		    sprintf(buf,"%s_%d_%d","C",i,iRow);
			///////////////////////////////////// in THE List 
			pAddNode = PostNode(*pNid,LEVEL_KIDDO,wLocalPos,FALSE);	// Create DrNode
			delete pNid;
			/////////////
			if(!pAddNode)	// Create DrCNode
				return MA_ERROR;
			///////////////////////////////////// in Curve 	
			pCNodeList->InsertObject(pAddNode); //CNodeList
			/////////////////////////////////////////////// Save Wts
			pWts[i] = Wts;
		}
		else
			return MA_ERROR;
	}
	/////////////
	return MA_OK;
}

int CMP_CooP4::CreateFillINodeList_T(CDrPatch* pDrPatch,int iCurve_V,int nINode_V/*BzJnPts_S*/,
					int nDegree_S,int nDegree_T,int nConBZ_S,CDListMgr* pINodeList)
{
	int nResult;
	//////////////////////////////////////
	CDListMgr* pCNList	= pDrPatch->GetCNodeList();
	CString PatchID		= pDrPatch->GetObjectID();
	//////////////////////
	nResult =  PackINodeList_T(PatchID,pCNList,iCurve_V,nINode_V,nDegree_S,nDegree_T,
																pINodeList,nConBZ_S);
	////////////
	if(nResult == MA_ERROR)
		return MA_ERROR;
	//////////////
	return MA_OK;
}

int CMP_CooP4::PackINodeList_T(CString& PatchID,CDListMgr* pCNodeList,int iCurve_V,int nINode_V,
							int nDeg_U,int nDeg_V,CDListMgr* pINodeList,int nConBZ_S)
{
	// Packs Jn. Pts. of CNodeList as INODES
	/////////////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument(); 
	CObjectMgr* pObjectMgr  = pDoc->GetObjectMgr(); 
	///////////////////
	int			i,index,iRow;
	CDrNode*	pCNode;
	CDrNode*	pINode;
	WORLD		wLocalPos;
	CString		ID;
	CDrLabel*	pLabel;
	int			nNodeIndex,nLabelIndex;
	////////////////////////
	pINodeList->RemoveAll();
	////////////////////////
	iRow	= iCurve_V * nDeg_U /*= iRow*/;
	for(i=0;i<nINode_V;i++)
	{
		index	= iRow + i * nDeg_V * nConBZ_S; 
		pCNode	= (CDrNode*)pCNodeList->GetObject(index);
		/////
		if(pCNode)
		{
			//////////////////////////////// Create an INode
			pObjectMgr->SetObjInfoID(ID,INODE);
//			ID += "_" + PatchID;
			wLocalPos = *(pCNode->GetLocalPos());
			/////////////////////////// Create Anyway
			nNodeIndex = -12345;
			pINode = CreateNode(ID,pLabel,wLocalPos,FALSE/*Not CNode*/,TRUE,
									nNodeIndex,nLabelIndex,LEVEL_GRAPA);
			//////////////////////////////////
			if(!pINode)	// Create DrCNode
			return MA_ERROR;
			///////////////////////////////////
			pINodeList->InsertObject(pINode);
		}
	}
	/////////////
	return MA_OK;
}
/////////////////////////////////////////////////////////////////////////////////////
int CMP_CooP4::SetDataFromCurve_Lattice(CDrCurve* pCurve)
{
	int i;
	pINT	pNum_t_S;
	pDOUBLE	pDis_t_S;
	/////////////
	m_bClosed_S			= pCurve->IsClosed_S();
//			m_nDim_S			= pCurve->GetnDim_S();
	m_nDim_S			= 4;					// ALWAYS Rational;
	m_nOrder_S			= pCurve->GetOrder_S();
	m_nMaxPatchCNodes_S	= pCurve->GetMaxCNodes_S();
	m_nSegs_S 			= pCurve->GetMaxBezSegments_S(); 
//			m_CurveType_S		= pCurve->GetCurveType_S();
	m_CurveType_S		= CP_NURB;				// ALWAYS
	///
	m_nOut_S			= (int)pCurve->GetLongOutPts();
//	m_nMaxOSeg_S		= pCurve->GetSegmentCount_S();
	m_nMaxOSeg_S		= pCurve->GetMaxOutSeg_S();
	m_bUnifOT_S			= pCurve->IsUniform_S();
	//////////////////////////////////////////////////
	pNum_t_S			= pCurve->GetNum_tPointer_S();
	pDis_t_S			= pCurve->GetDis_tPointer_S();
	///
	if(pNum_t_S)
		m_pNum_t_S		= new int[m_nSegs_S];
	if(pDis_t_S)
		m_pDis_t_S		= new double[m_nOut_S];
	///////
	for (i=0;i<m_nSegs_S;i++)
	{
		if(pNum_t_S)
			m_pNum_t_S[i]		= pNum_t_S[i];
	}
	for (i=0;i<m_nOut_S;i++)
	{
		if(pDis_t_S)
			m_pDis_t_S[i]		= pDis_t_S[i];
	}
	////////
	return MA_OK;
}

int CMP_CooP4::SetInfoDataBase_LatticeCurve(CDrCurve* pDrObject)
{
	///////////////////////////////////////
	CDrGrafDoc* pDoc 		= ((CDrGrafApp*)AfxGetApp())->GetDocument();
	CObjectMgr* pObjectMgr 	= pDoc->GetObjectMgr();
	///////////////////////////////////////////////
	CDrPen*	pDrPen			= (CDrPen*)pObjectMgr->GetSpecObject(DRPEN);
	CLayer* pLayer			= (CLayer*)pObjectMgr->GetSpecObject(LAYER); 
	//////////////////////////////////////////////////// Update Current DrObject
    pDrObject->SetObjectType((int)CURVE);
    pDrObject->SetElemType((int)GENR_OBJECT);          // globals
    pDrObject->SetLevelType((int)LEVEL_GRAPA);          // globals
	pDrObject->SetCurveType_S(CP_NURB);
	////////////////////////////////////////////////////// 
	SetInfo_LatticeCurve(pDrObject);
	////////////////////////////////////////////////////////////////////////////////	
	pDrObject->SetPenInfo(pDrPen->GetWidth(),pDrPen->GetColor(),pDrPen->GetStyle());
	pDrObject->SetLayer(pLayer->GetCurrentLayer());
	////////////////////////////////////// LOCAL 3DBounds using
										// ConVexHull Property
	pDrObject->Calc_3DBoundsLocal();
	pDrObject->SetDirty(TRUE);
	///////
	return MA_OK;
}

void CMP_CooP4::SetInfo_LatticeCurve(CDrCurve* pDrObject)
{
	///////////////////////////////////////////////////////////////// All Other
	pDrObject->SetRatio_S(m_Ratio_S);					
	pDrObject->SetUniform_S(m_bUnifOT_S);		// Output Distribution:
	pDrObject->SetMaxOutSeg_S(m_nMaxOSeg_S);	// Number of Output Segments
//?
	//////////////////////////////////////////
	pDrObject->SetCurveType_S(m_CurveType_S);
	pDrObject->SetMaxCNodes_S(m_nMaxPatchCNodes_S);
	pDrObject->SetMaxBezSegments_S(m_nSegs_S);	
	pDrObject->SetClosed_S(m_bClosed_S);
	pDrObject->SetOrder_S(m_nOrder_S);
	pDrObject->SetnDim_S(4);	// ALWAYS RATIONAL
	////////////////////////////////////////////////////////////////////// Mesh(Output)
	pDrObject->SetOutMethod_S(CO_HORNER);		// Output Method
//	pDrObject->SetSegmentCount_S(m_nMaxOSeg_S); 	// for Old Compatibility
	pDrObject->SetLongOutPts(m_nOut_S);
	pDrObject->SetMaxOutPts_S(m_nOut_S);
	pDrObject->SetUniform_S(m_bUnifOT_S);		// Output Distribution:
	pDrObject->SetNum_tPointer_S(m_pNum_t_S);	// Number of Outputs for each Output Segment
	/////////////////////////////////////////
	pDrObject->SetDis_tPointer_S(m_pDis_t_S);	// s-distribution
    ////////////////////////////////////////////////////////////////////// Reciprocate 	
	CDListMgr* pINodeList = pDrObject->GetINodeList();
   /////////////////
	for (POSITION posI = pINodeList->GetHeadPosition( );posI !=NULL;)
	{
		////
		CDrNode* pDrNode = (CDrNode*)pINodeList->GetNextObject(posI);
		////////////////////////////////// save curve
		int index = (pDrNode->GetCurveList())->GetObjectIndex(pDrObject); // exists already?
		if(index>=0)
			continue;
		/////////////
		pDrNode->GetCurveList()->InsertObject(pDrObject);
	}
	////////////////////////////////////////////////////////////// interpolation
    int nData = pINodeList->GetCount();
	/////////
	pDrObject->SetData_S(nData);		// GIVEN: # of Data
	pDrObject->SetMaxINodes_S(nData);
	pDrObject->SetOrder_S(m_nOrder_S);				// k
	//////////////////////////////////////////////// Update	 
	m_nControls 	= nData + m_nOrder_S - 2;	        // L + k - 1 = nData + k - 2 = n + 1
	m_nCurveSeg 	= nData - 1;
	m_nMaxDistinct 	= nData;
	m_nMaxTotal		= nData + (2 * m_nOrder_S - 2);	// n + k + 1 = nData + (2k - 2)
	if(m_bClosed_S)
	{
		m_nCurveSeg++;
		m_nMaxDistinct++;
		m_nMaxTotal++;
	}
	////////////////////////////////////////////////////////
	pDrObject->SetnCon_BS_S(m_nControls);	// L + k - 1
											// = nData + k - 2
											// = n + 1 (B-Spline));
	pDrObject->SetnKnots_S(m_nMaxDistinct);
	pDrObject->SetnMKnots_S(m_nMaxTotal);
	////////////////////////////////////////
	int nCon_BZ	= (m_nOrder_S - 1) * m_nCurveSeg + 1;	// (k-1) * L + 1 , Open
	if(m_bClosed_S)
		nCon_BZ--; 		
	pDrObject->SetnCon_BZ_S(nCon_BZ); // = m_nMaxCurveCNodes(Eventually)
	/////////////////////////////////////
	return;
}
//////////////////////////////////////////////////////////////////////////////////////
void CMP_CooP4::Serialize(CArchive& ar)
{

	CMI_GangP::Serialize( ar);              // must call base class Serializer
	/////////////////////////
	////////////////////////////
	if (ar.IsStoring())
	{
		TRACE(" CMP_CooP4:    Storing\n");	
		
 			/////////////////////////////////////////////////
 			//////////////////////////////

	}
	else
	{
		TRACE(" CMP_CooP4:    Loading\n");	

			/////////////////////////////////////////////////
 		//////////////////////////////
	
	}        
	//////////////////
}
///////////////////////////////// end of module ///////////////////
