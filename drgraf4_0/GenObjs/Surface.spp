// CSurface.cpp : implementation of the CSurface class
//

#include "stdafx.h"
#include <math.h>
#include <Float.h>		//DBL_MIN in sweep/duct
/////////////////////
#include "glb_Type.h"
#include "glb_Objs.h"
#include "glb_CuPS.h"
///////////////////
#include "Surface.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CSurface

IMPLEMENT_DYNAMIC(CSurface,CObject)
/*
BEGIN_MESSAGE_MAP(CSurface,CObject)
//BEGIN_MESSAGE_MAP
	//{{AFX_MSG_MAP(CSurface)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
*/
//////////////////////////////////////////////
static DMAT
	CoefBezier		= {	{ -1,	 3,	-3,	1 },
						{  3,	-6,	 3,	0 },
						{ -3,	 3,	 0,	0 },
						{  1,	 0,	 0,	0 }	}
,	CoefBSpline		= { { -0.166666666F, 	0.5F, 			-0.5F,  		0.166666666F},
						{  0.5F,			-1,  			0.5F,  			0 			},
						{ -0.5F,			0,  			0.5F,  			0 			},
						{  0.166666666F,	0.66666666F,	0.166666666F,	0 			}	}
,	CoefCatmullRom	= {	{ -0.5F,	 1.5F,	-1.5F,	0.5F	},
						{  1,		-2.5F,	 2,		-0.5F	},
						{ -0.5F,	 0,	 	0.5F,	0		},
						{  0,	 	1,	 	0,		0		}	}
,	CoefHermite		= {	{  2, -2,  1,  1 },
						{ -3,  3, -2, -1 },
						{  0,  0,  1,  0 },
						{  1,  0,  0,  0 }	}
,	CoefBeta		= {	{ -2,  2, -2,  2 },
						{  6, -3,  3,  0 },
						{ -6,  6,  6,  0 },
						{  2,  1,  2,  0 }	}
;


#define	SCALEP(a,b)			(a).x = (a).x * (b);\
							(a).y = (a).y * (b);\
							(a).z = (a).z * (b)
#define	SUBP(a,b,c)			(c).x = (a).x - (b).x;\
							(c).y = (a).y - (b).y;\
							(c).z = (a).z - (b).z
#define	P2F3D(_a,_b)	(_b).x = (_a).x; (_b).y = (_a).y; (_b).z = (_a).z

//////////////////////
CSurface::CSurface()
{ 
	m_nsubdivisions	= 1;

} 
///////////////////////////////////////////////////////////////////// Memory BlockCopy
#pragma optimize("",off)
void CSurface::BlockCopy(HUGEBLK p1, HUGEBLK p2, HUGESIZE size)
{
					if( p1 && p2 )
					HUGECOPY(p1, p2, size);
}
#pragma optimize("",on) 
/////////////////////////////////////////////////////////////////////
int CSurface::NumberOfCubicPatches(enum CURVETYPE kind, int nCtlU, int nCtlV,
					int nSegU,int nSegV,BOOL bCloseU,BOOL bCloseV,
					int* pnPU, int* pnPV,int* pnOut_U, int* pnOut_V)
{ 
	////////////////////////////////////////////////////////////////////////
	// 	Return: 	np 		= No. of Output Pts. to be generated                      
	//	Parameter modified:
	//				pnPU 	= No. of Cubic Patches in U-direction 
	//				pnPV 	= No. of Cubic Patches in V-direction 
	////////////////////////////////////////////////////////////////////////
	int du,dv;
	if( !(du = CtlPtStep( kind )) )
		return -1;
	////////////////////////////////////
	dv = du;
	////////
	*pnPU = bCloseU ? nCtlU/du : (nCtlU - 4)/du + 1;
	*pnPV = bCloseV ? nCtlV/dv : (nCtlV - 4)/dv + 1;

	*pnOut_U = nSegU * (*pnPU) + 1;
	*pnOut_V = nSegV * (*pnPV) + 1;
//	np = (nSegU*(*pnPU)+1) * (nSegV*(*pnPV)+1);
	///////////////////////////////
	return 0;
	////////

} 

int CSurface::NumberOfLinearPatches(enum CURVETYPE kind, int nCtlU, int nCtlV,
					int nSegU,int nSegV,BOOL bCloseU,BOOL bCloseV,
					int* pnPU, int* pnPV,int* pnOut_U, int* pnOut_V)
{ 
	////////////////////////////////////////////////////////////////////////
	// 	Return: 	np 		= No. of Output Pts. to be generated                      
	//	Parameter modified:
	//				pnPU 	= No. of Linear Patches in U-direction  
	//				pnPV 	= No. of Linear Patches in V-direction 
	////////////////////////////////////////////////////////////////////////
	*pnPU = bCloseU ? nCtlU : nCtlU - 1; 			// always
	*pnPV = bCloseV ? nCtlV : nCtlV - 1;

	*pnOut_U = nSegU * (*pnPU) + 1;
	*pnOut_V = nSegV * (*pnPV) + 1;
//	np = (nSegU*(*pnPU)+1) * (nSegV*(*pnPV)+1);
	///////////////////////////////
	return 0;
	////////

} 

int CSurface::CtlPtStep(enum CURVETYPE kind)
{
	switch( kind ) {
		case CU_NURB:			return 1;
		case CU_BSPLINE:		return 1;
		case CU_CATMULLROM:		return 1;
		case CU_BEZIER:			return 3;
		case CU_HERMITE:		return 2;
		case CU_BETA:			return 1;
	}
	return 0;
}

PDMAT CSurface::SetBasis(enum CURVETYPE kind,double bias,double tension)
{
	DMAT	BasisBeta = {	{ -2,  2, -2,  2 },
							{  6, -3,  3,  0 },
							{ -6,  6,  6,  0 },
							{  2,  1,  2,  0 }	};
	PDMAT	C;
	double	r,bias2,bias3;
	int		i,j;

	switch( kind ) {
		case CU_BSPLINE:		return (PDMAT)CoefBSpline;
		case CU_CATMULLROM:		return (PDMAT)CoefCatmullRom;
		case CU_BEZIER:			return (PDMAT)CoefBezier;
		case CU_HERMITE:		return (PDMAT)CoefHermite;
		case CU_BETA:			break;
	}
	C = (PDMAT)CoefBeta;
	BlockCopy( (HUGEBLK)BasisBeta, (HUGEBLK)C, sizeof(BasisBeta) );
	bias2 = bias * bias;
	bias3 = bias2 * bias;
	for( i=0;i<3; i++ )
		C[i][0] *= bias3;
	C[0][1] *= tension + bias3 + bias2 + bias;
	C[0][2] *= tension + bias2 + bias + 1;
	C[1][1] *= tension + 2 * bias3 + 2 * bias2;
	C[1][2] *= tension + 2 * bias2;
	C[2][1] *= bias3 - bias;
	C[2][2] *= bias;
	C[3][1] *= tension + 4 * ( bias2 + bias );
	r = 1.0F / (tension + 2*bias3 + 4*bias2 + 4*bias + 2);
	for( i=0; i<4; i++ )
		for( j=0; j<4; j++ )
			C[i][j]*=r;
	return C;
}

PDMAT CSurface::ForwardDifference(int nSegs)
{
	if(nSegs<1) return (PDMAT)NULL;
	///////////////////////////////////
	// Forward Difference Matrix: Foley p 535
	static	DMAT E;
	////////////////////////////
	double delta	= 1.0/nSegs;
	////////////////////////////////////////// E(epsilon): Forward Difference
	E[0][0]=E[0][1]=E[0][2]=E[1][3]=E[2][2]=E[2][3]=E[3][1]=E[3][2]=E[3][3] = 0;
	E[0][3]=1.0;
	E[1][2]=delta;
	E[1][1]=delta * delta;
	E[1][0]=E[1][1] * delta;
	E[2][0]=E[3][0] = E[1][0] * 6.0;
	E[2][1]=E[1][1] * 2.0;
	//////////////////////////////////////////
	return (PDMAT)E; 
}

void CSurface::ComputeEUM_G_XposeEVM(PWMAT DOO,PDMAT EUM, PDMAT EVM, PWMAT G)
{

	///////////////////////////////////
	// Set up Doo = E(epsilon)_Ci_TransposeE(delta):(i = x,y,z)
	// Forward Difference Method: Foley p 535
	int i,j,k,l;
	double t,tx,ty,tz;
	////////////////////////////////////////// 
	// multiply EUM_G_EVMtranspose, 
	for(i=0; i<4; i++)
	{
		for(j=0; j<4; j++) 
		{
			tx = 0;ty = 0;tz = 0;
			for(k=0; k<4; k++)
			{
				for(l=0; l<4; l++)
				{   
					t = EUM[i][k] * EVM[j][l]; 
					tx += t * G[k][l].x;
					ty += t * G[k][l].y;
					tz += t * G[k][l].z;
				}
			}		
			DOO[i][j].x = tx;
			DOO[i][j].y = ty;
			DOO[i][j].z = tz;
		}
	}	
}

void CSurface::ComputeEUorV_x_M(PDMAT EM, PDMAT FD, PDMAT M)
{
	int		i,j,k;
	double	t;

	// multiply FD (ForwardDiff) by M (Coeff.) = EUM or EVM 
	for(i=0; i<4; i++)
	{
		for(j=0; j<4; j++) 
		{
			t = 0;
			for(k=0; k<4; k++)
				t += FD[i][k]*M[k][j];
			EM[i][j] = t;
		}
	}		
}

int CSurface::GeneratePointsOnCubic(PWMAT D,int nSegU,int nSegV,WORLD P[],
									int nPatchU,
									int uCur,int vCur,int nMaxU, int nMaxV)
{
	//**************************************************
	// Output Points generate for each CubicPatch:
	// Forward Difference Method: Foley p 535
	// Correspondence:
	// 	s<->U, epsilon; t<->V,delta; 
	// We want to store:
	// 	for V or t = 0		: all USegs , then 
	//	for V ot t = delta	: all USegs , and so on 
	//************************************************** 
	int m,n,i,nOut=0;
	WORLD fo,dfo,d2fo,d3fo;
	long k;
	////////////////////////////////////////////////////////// Compute Points(x,y,z)
	for (m=0; m<nMaxV; m++)
	{
		//////////////////////////////////////////////// for all U
/*
		fo 		= D[0][0];	
		dfo 	= D[1][0];	
		d2fo 	= D[2][0];	
		d3fo 	= D[3][0];
*/		
		fo 		= D[0][0];	
		dfo 	= D[0][1];	
		d2fo 	= D[0][2];	
		d3fo 	= D[0][3];
		//////////////////	
		for (n=0; n<nMaxU; n++)
		{
			nOut++;          // increment points created
			////////////////////////////////////////////
			k = vCur * ((nPatchU*nSegU + 1)*nSegV)	+
				   m * (nPatchU*nSegU + 1)			+
				uCur * nSegU						+
				   n;
			////////////////////////////////////////////		   
//			P->x = fo.x;	
//			P->y = fo.y;	
//			P->z = fo.z;
			P[k].x = fo.x;	
			P[k].y = fo.y;	
			P[k].z = fo.z;
			/////////////// iterate for next U or s or epsilon
			fo.x 		+= dfo.x;
			fo.y 		+= dfo.y;
			fo.z 		+= dfo.z;
			
			dfo.x		+= d2fo.x;
			dfo.y		+= d2fo.y;
			dfo.z		+= d2fo.z;
			
			d2fo.x		+= d3fo.x;
			d2fo.y		+= d3fo.y;
			d2fo.z		+= d3fo.z;
			///////////////
//			P++;
		} 
		/////////////////// iterate for next V or t or delta 
		for (i = 0;i<4;i++)
		{
/*
			D[i][0].x += D[i][1].x;	//Col1=Col1+Col2 
			D[i][0].y += D[i][1].y;	//Col1=Col1+Col2 
			D[i][0].z += D[i][1].z;	//Col1=Col1+Col2 

			D[i][1].x += D[i][2].x;	//Col2=Col2+Col3 
			D[i][1].y += D[i][2].y;	//Col2=Col2+Col3 
			D[i][1].z += D[i][2].z;	//Col2=Col2+Col3 

			D[i][2].x += D[i][3].x;	//Col3=Col3+Col4 
			D[i][2].y += D[i][3].y;	//Col3=Col3+Col4 
			D[i][2].z += D[i][3].z;	//Col3=Col3+Col4
*/			 
			D[0][i].x += D[1][i].x;	//Row1=Row1+Row2 
			D[0][i].y += D[1][i].y;	//Row1=Row1+Row2 
			D[0][i].z += D[1][i].z;	//Row1=Row1+Row2 

			D[1][i].x += D[2][i].x;	//Row2=Row2+Row3 
			D[1][i].y += D[2][i].y;	//Row2=Row2+Row3 
			D[1][i].z += D[2][i].z;	//Row2=Row2+Row3 

			D[2][i].x += D[3][i].x;	//Row3=Row3+Row4 
			D[2][i].y += D[3][i].y;	//Row3=Row3+Row4 
			D[2][i].z += D[3][i].z;	//Row3=Row3+Row4 
		}
	}
	////////////////		
	return nOut;	
}	
	
void CSurface::ComputeFDiff_x_Mcoeff
		(
			enum CURVETYPE	kind
		,	double			bias			// beta
		,	double			tension			// beta and hermite
		,	int				nSegU			// number of Intervals in U direction/cubic curve
		,	int				nSegV			// number of Intervals in V direction/cubic curve
		,	PDMAT			EUM
		,	PDMAT			EVM
		)
{
	DMAT		MCoeff,FDiff_U,FDiff_V;
	PDMAT		pMCoeff = (PDMAT)MCoeff,pFDiff_U = (PDMAT)FDiff_U,
										pFDiff_V = (PDMAT)FDiff_V,B,FD;
	//////////////////////////////////////////////////// Coeff Matrix
	B = SetBasis( kind, bias, tension );
	BlockCopy( (HUGEBLK)B, (HUGEBLK)pMCoeff, sizeof(double)*16 );
	//////////////////////////////////////////////////// ForwardDifference Matrices
	FD = ForwardDifference(nSegU);
	BlockCopy( (HUGEBLK)FD, (HUGEBLK)pFDiff_U, sizeof(double)*16 );
	//////////////////////////////////////////////////// Compute FDiffUxMCoeff 
	ComputeEUorV_x_M(EUM,FDiff_U,MCoeff);  // used to multply matrices
	////////////////////////////////////////////////////
	FD = ForwardDifference(nSegV);
	BlockCopy( (HUGEBLK)FD, (HUGEBLK)pFDiff_V, sizeof(double)*16 );
	//////////////////////////////////////////////////// Compute FDiffUxMCoeff 
	ComputeEUorV_x_M(EVM,FDiff_V,MCoeff);  // used to multply matrices
	//////////////////////////////////
	return;
}	

int CSurface::MakePatchesToFit
	(
		enum CURVETYPE kind,	//	cubic basis function selection
		double		bias,	//	beta
		double		tension,//	beta and hermite
		int			nCtlU,	//	number of control vertices in U direction
		int			nSegU,	//	number of intervals in U direction
		int			nCtlV,	//	number of control vertices in V direction  	IN CALLING ROUTINE
		int			nSegV,	//	number of intervals in V direction
		pWORLD		ptCntrl,//	array of control vertices
		pWORLD		pOut,	//	array of Output 3D World Points
		int			nPU,	// 	Total Number of Cubic Patches in U direction
		int			nPV,	// 	Total Number of Cubic Patches in V direction
		PDMAT		EUM,	// EM Matrix
		PDMAT		EVM		// EM Matrix
	)
{
	BOOL	bEndU,bEndV;
	WMAT	DOO,G;
	WORLD	d,*P;
	pWORLD	p,pv;
	int		u, v, du, dv, VnCU,	nOut = 0, nMaxU,nMaxV;
	int		U[4], V[4], vIx[4][4];	// vertex indices
	//////////////////////////////////////////////////// Control pt steps
	p	= pOut;
	du 	= CtlPtStep( kind );
	dv 	= du;
	//////////////////////////////////////////////////////////////////// LOOP		
	for( V[0] = v = 0; v < nPV; v++, V[0]+=dv ) 
	{
		V[1] = (V[0]+1) % nCtlV;
		V[2] = (V[0]+2) % nCtlV;
		V[3] = (V[0]+3) % nCtlV;
		/////////////////////////////////////////// U direction Cubic Patches
		for( U[0] = u = 0; u < nPU; u++, U[0]+=du ) 
		{
			U[1] = (U[0]+1) % nCtlU;
			U[2] = (U[0]+2) % nCtlU;
			U[3] = (U[0]+3) % nCtlU;
			VnCU = V[0] * nCtlU;
			vIx[0][0] = VnCU + U[0]; vIx[0][1] = VnCU + U[1];
			vIx[0][2] = VnCU + U[2]; vIx[0][3] = VnCU + U[3];			
			VnCU = V[1] * nCtlU;
			vIx[1][0] = VnCU + U[0]; vIx[1][1] = VnCU + U[1];
			vIx[1][2] = VnCU + U[2]; vIx[1][3] = VnCU + U[3];
			VnCU = V[2] * nCtlU;
			vIx[2][0] = VnCU + U[0]; vIx[2][1] = VnCU + U[1];
			vIx[2][2] = VnCU + U[2]; vIx[2][3] = VnCU + U[3];
			VnCU = V[3] * nCtlU;
			vIx[3][0] = VnCU + U[0]; vIx[3][1] = VnCU + U[1];
			vIx[3][2] = VnCU + U[2]; vIx[3][3] = VnCU + U[3];
			///////////////////////////////////////////////// Geometry Matrix 
			// construct geometry matrix for patch
			for(int i=0; i<4; i++ ) 
			{
				if( kind == CU_HERMITE ) 
				{
					// geometry vector [p0 p3 t0 t3]
					double	s = tension;
					P2F3D( ptCntrl[vIx[i][0]], G[i][0] );	// p0
					P2F3D( ptCntrl[vIx[i][3]], G[i][1] );	// p3
					SUBP( ptCntrl[vIx[i][1]], ptCntrl[vIx[i][0]], d );
					SCALEP( d, s ); P2F3D( d, G[i][2] );// t0 = (p1-p0)*s
					SUBP( ptCntrl[vIx[i][3]], ptCntrl[vIx[i][2]], d );
					SCALEP( d, s ); P2F3D( d, G[i][3] );// t3 = (p3-p2)*s
				}
				else
				for(int j=0; j<4; j++ ) 
				{	
					pv = ptCntrl+vIx[i][j];
					P = &G[i][j];
					P2F3D( *pv, *P );
				}
   		 	}
			///////////////////////////////////////////////// Cubic Patch
//			ComputeEUM_G_XposeEVM(DOO,EUM,EVM,G);
			ComputeEUM_G_XposeEVM(DOO,EVM,EUM,G);
			/////////////////////////////////////////////////
			bEndU = FALSE;
			bEndV = FALSE;
			if(u == (nPU-1)) bEndU = TRUE;
			if(v == (nPV-1)) bEndV = TRUE;
			/////////////////////////////
			nMaxU = bEndU?(nSegU+1):nSegU; // no. of pts to be generated in U
			nMaxV = bEndV?(nSegV+1):nSegV; // no. of pts to be generated in V
//			nOut +=GeneratePointsOnCubic(DOO,nSegU,nSegV,p,bEndU,bEndV,nMaxU,nMaxV );
			nOut +=GeneratePointsOnCubic(DOO,nSegU,nSegV,pOut,
											nPU,u,v,nMaxU,nMaxV );
			/////////////////////////////
//			p += nMaxU*nMaxV;
		}
	}
	////////////
	return nOut;
	////////////
/*
//	xfMatrix2Patch( hG, ixP, 0, -1, (nSV*nPV+1), np, pV, pRA, xf );
	delete pV;
*/	
}
//////////////////////////////////////////////////////////////////////
int	CSurface::Generate_Cubics
	(
		enum CURVETYPE kind,	//	cubic basis function selection
//		BOOL	 	uClosed,//	closed curve in U direction?  				IN CALLING ROUTINE
		int			nCtlU,	//	number of control vertices in U direction
		int			nSegU,	//	number of intervals in U direction
//		BOOL		vClosed,//	closed curve in V direction?
		int			nCtlV,	//	number of control vertices in V direction  	IN CALLING ROUTINE
		int			nSegV,	//	number of intervals in V direction
		pWORLD		ptCtl,	//	array of control vertices
		pWORLD		pOut,	//	array of Output 3D World Points
		int			nPU,	// 	Total Number of Cubic Patches in U direction
		int			nPV,	// 	Total Number of Cubic Patches in V direction
		int			nOutU,	//	expected number of generated curve vertices in U	
		int			nOutV,	//	expected number of generated curve vertices in V	
		int			nOut	//	expected number of generated curve vertices	
	)
{
    ///////////////////////////////////
	if((!nCtlU)||(!nCtlV)||(!ptCtl)||(!pOut)||(nPU<1)||(nPV<1))
		/*	Lets be reasonable, ok folks? We MUST have these items.
		 */
		return ERROR_MISSING_ARGUMENTS;
	///////////////////////////////////	
	/*	Generation of a BSpline curve requires at least five control( for close)
	 *	points, so verify that at least that many have been suppliE.
	 */
	if ((kind == CU_BSPLINE) && ((nCtlU< 5)||(nCtlV< 5)) )
		return	BSPLINE_TOO_FEW_POINTS;
    //////////////////////////////////////
/*
	if(!(nSegU))
		nSegU = 10;
	if(!(nSegV))
		nSegV = 10;
*/		
	//////////////////////////////////
	double bias		= 0.0;  //	beta
	double tension 	= 0.0;  //	beta and hermite
	if(kind == CU_HERMITE)
	{
		bias	= 1.0;
		tension = 6.0;
	}		
    ////////////////////////////////////////////////////// generate
    													// FDiffxMCoeff	
    DMAT EUM,EVM;
	ComputeFDiff_x_Mcoeff( kind, bias, tension,nSegU,nSegV,EUM,EVM);
	////////////////////////////////////////////////////// CreatePatchPts
	int nPtActual;
	if(pOut)
		nPtActual = MakePatchesToFit(kind,bias,tension,nCtlU,nSegU,nCtlV,nSegV,
										ptCtl,pOut,nPU,nPV,EUM,EVM);
	else
		return MEMORY_ERROR;
	if(nPtActual != nOut)
		return -1;	
    else
		return nPtActual;
}
//////////////////////////////////////////////////////////////////////
/*
int	CSurface::Generate_Quadratics
	(
		enum CURVETYPE kind,	//	cubic basis function selection
//		BOOL	 	uClosed,//	closed curve in U direction?  				IN CALLING ROUTINE
		int			nCtlU,	//	number of control vertices in U direction
		int			nSegU,	//	number of intervals in U direction
//		BOOL		vClosed,//	closed curve in V direction?
		int			nCtlV,	//	number of control vertices in V direction  	IN CALLING ROUTINE
		int			nSegV,	//	number of intervals in V direction
		pWORLD		ptCtl,	//	array of control vertices
		pWORLD		pOut,	//	array of Output 3D World Points
		int			nPU,	// 	Total Number of Cubic Patches in U direction
		int			nPV,	// 	Total Number of Cubic Patches in V direction
		int			nOutU,	//	expected number of generated curve vertices in U	
		int			nOutV,	//	expected number of generated curve vertices in V	
		int			nOut	//	expected number of generated curve vertices	
	)
{
	// todo later
	return -1;
}
*/
//////////////////////////////////////////////////////////////////////
int	CSurface::Generate_Linears
	(
//		BOOL	 	bCloseU,	//	closed in U direction?
		int			nCtlU,		//	number of control vertices in U direction
		int			nSegU,		//	number of intervals in U direction
//		BOOL		bCloseV,	//	closed in V direction?
		int			nCtlV,		//	number of control vertices in V direction  	IN CALLING ROUTINE
		int			nSegV,		//	number of intervals in V direction
		pWORLD		ptCtl,		//	array of Input control vertices
		pWORLD		pOut,		//	array of Output 3D World Points
		int			nPU,		// 	Total Number of Cubic Patches in U direction
		int			nPV,		// 	Total Number of Cubic Patches in V direction
		int			nOutU,		//	expected number of generated curve vertices in U	
		int			nOutV,		//	expected number of generated curve vertices in V	
		int			nOut		//	expected number of generated curve vertices	
	)
{
/*
	int i,j,jj=0;
	pWORLD pS,pE,p,pRow;
	double rU,rV,rr;
*/	
	////////////////////////////////////////////////
	if((nSegU<1)||(nSegV<1)||(nCtlU<2)||(nCtlV<2)||
	 (ptCtl==NULL)||(pOut==NULL) )
		return -1;
	//////////////////////		
	int nPtActual;
	if(pOut)
		nPtActual = MakePatchesToFit(nCtlU,nSegU,nCtlV,nSegV,
										ptCtl,pOut,nPU,nPV);
	else
		return MEMORY_ERROR;
	/////////////////////	
	if(nPtActual != nOut)
		return -1;	
    else
		return nPtActual;
	/////////////////////
}

int CSurface::MakePatchesToFit
	(
		int			nCtlU,	//	number of control vertices in U direction
		int			nSegU,	//	number of intervals in U direction
		int			nCtlV,	//	number of control vertices in V direction  	IN CALLING ROUTINE
		int			nSegV,	//	number of intervals in V direction
		pWORLD		ptCntrl,//	array of control vertices
		pWORLD		pOut,	//	array of Output 3D World Points
		int			nPU,	// 	Total Number of Cubic Patches in U direction
		int			nPV		// 	Total Number of Cubic Patches in V direction
	)
{
	WMAT2	G;
	double	rU,rV;
	BOOL	bEndU,bEndV;
	pWORLD	p,pv,P;
	int		u, v, du, dv, VnCU,	nOut = 0, nMaxU,nMaxV;
	int		U[2], V[2], vIx[2][2];	// vertex indices
	//////////////////////////////////////////////////// Control pt steps
	p	= pOut;
	du 	= 1;
	dv 	= du;
	//////////////
	rU = 1./nSegU; 
	rV = 1./nSegV; 
	//////////////////////////////////////////////////////////////////// LOOP		
	for( V[0] = v = 0; v < nPV; v++, V[0]+=dv ) 
	{
		V[1] = (V[0]+1) % nCtlV;
		/////////////////////////////////////////// U direction Linear Patches
		for( U[0] = u = 0; u < nPU; u++, U[0]+=du ) 
		{
			U[1] = (U[0]+1) % nCtlU;
			////////////////////////
			VnCU = V[0] * nCtlU;
			vIx[0][0] = VnCU + U[0]; 
			vIx[0][1] = VnCU + U[1];
			VnCU = V[1] * nCtlU;
			vIx[1][0] = VnCU + U[0]; 
			vIx[1][1] = VnCU + U[1];
			///////////////////////////////////////// Geometry Matrix 
			// construct geometry matrix for patch
			for(int i=0; i<2; i++ ) 
			{
				for(int j=0; j<2; j++ ) 
				{	
					pv = ptCntrl+vIx[i][j];
					P = &G[i][j];
					P2F3D( *pv, *P );
				}
   		 	}
			/////////////////////////////////////////////////
			bEndU = FALSE;
			bEndV = FALSE;
			if(u == (nPU-1)) bEndU = TRUE;
			if(v == (nPV-1)) bEndV = TRUE;
			/////////////////////////////
			nMaxU = bEndU?(nSegU+1):nSegU; // no. of pts to be generated in U
			nMaxV = bEndV?(nSegV+1):nSegV; // no. of pts to be generated in V
			//////////////////////////////
			nOut +=GeneratePointsOnLinear
					(G,nSegU,nSegV,rU,rV,pOut,nPU,u,v,nMaxU,nMaxV);
			/////////////////////////////
		}
	}
	////////////
	return nOut;
	////////////
}

int CSurface::GeneratePointsOnLinear
				(	
					PWMAT2 In,int nSegU,int nSegV,
					double rU,double rV,
					WORLD P[],int nPatchU,
					int uCur,int vCur,int nMaxU, int nMaxV
				)
{
	//**************************************************
	// Output Points generate for each LinearPatch:
	// We want to store:
	// 	for V or t = 0		: all USegs , then 
	//	for V ot t = delta	: all USegs , and so on 
	//************************************************** 
	int m,n,nOut=0;
	WORLD D00[2][2],fo,dfo;
	long k;
	///////////////////////////////
	D00[0][0] = In[0][0]; 

	D00[0][1].x = (In[1][0].x - In[0][0].x) * rV;
	D00[0][1].y = (In[1][0].y - In[0][0].y) * rV;
	D00[0][1].z = (In[1][0].z - In[0][0].z) * rV;
	
	D00[1][0].x = (In[0][1].x - In[0][0].x) * rU;
	D00[1][0].y = (In[0][1].y - In[0][0].y) * rU;
	D00[1][0].z = (In[0][1].z - In[0][0].z) * rU;

	D00[1][1].x = (In[0][0].x + In[1][1].x - In[1][0].x - In[0][1].x)
					* rU * rV;
	D00[1][1].y = (In[0][0].y + In[1][1].y - In[1][0].y - In[0][1].y) 
					* rU * rV; 
	D00[1][1].z = (In[0][0].z + In[1][1].z - In[1][0].z - In[0][1].z) 
					* rU * rV;
	/////////////////////////
	for (n=0; n<nMaxV; n++)
	{
		fo 	= D00[0][0];	
		dfo	= D00[1][0];	
		//////////////////////////////////////////////// for all U
		for (m=0; m<nMaxU; m++)
		{
			nOut++;          // increment points created
			////////////////////////////////////////////
			k = vCur * ((nPatchU*nSegU + 1)*nSegV)	+
				uCur * nSegU						+
				   n * (nPatchU*nSegU + 1)			+
				   m;
			////////////////////////////////////////////
			P[k] = fo;	
			/////////////// iterate for next U or s or epsilon
			fo.x += dfo.x;
			fo.y += dfo.y;
			fo.z += dfo.z;
/*
			/////////////// Brute Force Formula //////////			
			P[k].x = D00.x + m*du0.x + n*dv0.x + m*n*duv.x;	
			P[k].y = D00.y + m*du0.y + n*dv0.y + m*n*duv.y;	
			P[k].z = D00.z + m*du0.z + n*dv0.z + m*n*duv.z;
			///////////////////////////////////////////////
*/
		} 
		/////////////////// iterate for next V or t or delta 
		for (int i = 0;i<2;i++)
		{

			D00[i][0].x += D00[i][1].x;	//Col1=Col1+Col2 
			D00[i][0].y += D00[i][1].y;	//Col1=Col1+Col2 
			D00[i][0].z += D00[i][1].z;	//Col1=Col1+Col2 

		}
		//////////////////////////
		
	}
	////////////////		
	return nOut;	
}	
	
/*
int CSurface::LoftCurves
// Input Data Points Should be ALREADY TRANSFORMED in calling Routine
	(
		short	segs,	//	subdivision value (interior spaces)
		short	nPts,	//	number of input data points
		pWORLD	p0,		//	input data point array for start curve
		pWORLD	p1,		//	input data point array for end curve
		pWORLD 	pOut	//	Output Pts array
	)	  
// Return:	int	nOut	//	number of points emitted
{
	pWORLD	p;
	short	i,j,k=0;
	double	u,d,w;

//	p3da = (pPoint3d)NewPtr( (MBSIZE)nPts*segs*sizeof(Point3d) );
	if( pOut ) {
		d = 1./segs;
	    for( p = pOut, i = nPts - 1; i>=0; i-- )
	        for( u = 0., j = segs; j>=0; j--, u+=d, k++, p++ )
	        {
	        	w = 1. - u;
	            p->x = p0[i].x * w  + p1[i].x * u;
	            p->y = p0[i].y * w  + p1[i].y * u;
	            p->z = p0[i].z * w  + p1[i].z * u;
	        }
	}
	return k;
}
*/
int CSurface::LoftCurves
// Input Data Points Should be ALREADY TRANSFORMED in calling Routine
	(
		short	segs,	//	subdivision value (interior spaces)
		short	nPts,	//	number of input data points
		pWORLD	p0,		//	input data point array for start curve
		pWORLD	p1,		//	input data point array for end curve
		pWORLD 	pOut	//	Output Pts array
	)	  
//Return:Int	nOut	//	number of points emitted
{
	pWORLD	pRow;
	double	inc,u,w;
	int		nV,nT,i,j,k;
	long	sizeRow;

	nT = segs+1;
	nV = nPts*nT;
	/////////////
	if( pOut ) 
	{
		sizeRow = nPts*sizeof(WORLD);
		///////
		pRow=pOut; 
		BlockCopy( (HUGEBLK)p0, (HUGEBLK)pRow, sizeRow );
		pRow += nPts*(nT-1); 
		BlockCopy( (HUGEBLK)p1, (HUGEBLK)pRow, sizeRow );
		///////////////////////
		inc = 1./(double)segs;
	    for( i = 0; i<nPts; i++ )
	        for( u = inc, j = 1; j<nT-1; j++, u+=inc )
	        {
	        	w = 1. - u;
	        	k = j*nPts + i;
	            pOut[k].x = p0[i].x * w  + p1[i].x * u;
	            pOut[k].y = p0[i].y * w  + p1[i].y * u;
	            pOut[k].z = p0[i].z * w  + p1[i].z * u;
	        }
	}
 	return nV;
}

int CSurface::ExtrudeCurve
// Input Data Points Should be ALREADY TRANSFORMED in calling Routine
	(
		double	depth,	//	distance to the extended surface's end
		pWORLD	v,		//	unit extrusion vector (direction)
		int		segs,	//	subdivision value (interior spaces)
		int		nPts,	//	number of input data points
		pWORLD	pPt,	//	input data point array
		pWORLD	pOut	//	Output Pts array
	)	  
//Return:Int	nOut	//	number of points emitted
{
	pWORLD	pRow,p;
	double	inc,S;
	int		nV,nS,i,j;
	long	sizeRow;

	nS = segs+1;
	nV = nPts*nS;
//	pOut = (pPoint3d)NewPtr(sizeof(Point3d)*nV);
	if( pOut ) 
	{
		sizeRow = nPts*sizeof(WORLD);
		inc = depth/(double)segs;
		for( pRow=pOut,i=0;i<nS;i++,pRow+=nPts ) 
		{
			BlockCopy( (HUGEBLK)pPt, (HUGEBLK)pRow, sizeRow );
			S = inc * (double)i;
			for( p=pRow,j=0;j<nPts;j++,p++ ) 
			{
				p->x += S * (v->x);
				p->y += S * (v->y);
				p->z += S * (v->z);
			}
		}
	}
 	return nV;
}

int CSurface::RotateCurve
	(
		pWORLD	pAxisPt,//  a pt. on the rotation vector
		double	alpha,	//	initial position angle in degrees
		double	theta,	//	total rotation in degrees
		pWORLD	pAxis,	//	unit direction vector of rotation axis
		int		segs,	//	subdivision value (interior spaces)
		int		nPts,	//	number of input data points
		pWORLD	pPt,	//	input data point array
		pWORLD	pOut	//	Output Pts array
	)	  
//Return:Int	nOut	//	number of points emitted
/*************************************************************
//	r = (r dot n)n + [r - (r dot n)n] cos(theta)
//				   + [n cross (r - (r dot n)n)] sin(theta)
//	r = (r dot n)n (1 - cos(theta)) + r cos(theta)
//				   + [n cross r] sin(theta)
//	indicial:
//	r[i] = (r dot n)n[i] (1 - cos(theta)) + r[i] cos(theta)
//				   + (e[i][j][k].n[j].r[k]) sin(theta)
***************************************************************/
{
	//////////////
	pWORLD	pRow,p;
	double	inc,S,pi,radian,norm[4];
	int		nV,nS,ii,jj;
	long	sizeRow;
//	Matrix	R;
	////////////////////////////////
	int sign,i,j,k,tmp;
	double pt[4],out[4];
	double a,b,c,dot,cross;
	////////////////////////////////
//	pOut = (pPoint3d)NewPtr(sizeof(Point3d)*nV);
	if(pOut)
	{
		nS = segs+1;
		nV = nPts*nS;
		///////////////////////////// 
		pi = acos(-1.0);
		radian = pi/180.;
		sizeRow = nPts*sizeof(WORLD);
		inc = theta/(double)segs;//incremental rotation angle
		/////////////////////////////////////////////////////
		norm[1] = pAxis->x;
		norm[2] = pAxis->y;
		norm[3] = pAxis->z;
/*		/////////////////////////////////////////////////// Begin Checking		
		//////////////////////////////////////// for checking(temporary)
		double shift[4],mult=0.;
		shift[1] = pAxis->y;					  // assumed 12 plane
											  // Transformed
		shift[2] = -pAxis->x;
		shift[3] = 0.;
		//////////////////// mult = 2 times max proj. of given pts on plane
		for( p=pPt,jj=0;jj<nPts;jj++,p++ )
		{
			pt[1] = p->x;
			pt[2] = p->y;
			pt[3] = p->z;
			////////////////// 
			for (i=1;i<=3;i++)
			{
				/////////					
				dot = 0.;
				for(j=1;j<=3;j++)
					dot += pt[j]*shift[j];
			}
			////////////////			
			dot = fabs(dot);
			if(dot>mult) 
				mult = dot;
		}
		mult *= 2.;
		/////////////////////////////////////////////////// End Checking		
*/
		////////////////////////////////////////
		for( pRow=pOut,ii=0;ii<nS;ii++,pRow+=nPts ) 
		{
			BlockCopy( (HUGEBLK)pPt, (HUGEBLK)pRow, sizeRow );
//			S = alpha + inc * (double)i;
			S = (inc * (double)ii) * radian;
			///////////////////////
			b 		= cos(S);
			a 		= 1. - b;
			c 		= sin(S);
			/////////////
			for( p=pRow,jj=0;jj<nPts;jj++,p++ )
			{
				//////////////// Translate by point on Axis
				pt[1] = p->x - pAxisPt->x;
				pt[2] = p->y - pAxisPt->y;
				pt[3] = p->z - pAxisPt->z;
				////////////////// 
				for (i=1;i<=3;i++)
				{
					/////////					
					dot = 0.;
					for(j=1;j<=3;j++)
						dot += pt[j]*norm[j];
					out[i] = a*dot*norm[i] + b*pt[i];
					//////////////////
					j = (i+1>3)?1:i+1;
					k = (j+1>3)?1:j+1;
					cross = 0.;
					///////////
					for(sign = 1;sign>=-1;sign -=2)
					{
						cross += sign*norm[j]*pt[k];
						tmp = k;
						k	= j;
						j	= tmp;
					}
					out[i] += c*cross;
				}
				////////////////////// Translate Back
				p->x = out[1] + pAxisPt->x;
				p->y = out[2] + pAxisPt->y;
				p->z = out[3] + pAxisPt->z;

/*				////////////// for checking
				p->x += mult*shift[1];
				p->y += mult*shift[2];
				p->z += mult*shift[3];
				///////////////////////////
*/				
			}
		}			
	}
	return nV;
}

int CSurface::Sweep
	(
		//////////////////////////////////////////////////////	
		WORLD	XSecMove,	//	cross section Anchor point
		int		npSect,		//	number of cross section points
		pWORLD	ppSect,		//	cross section curve points
		int		npPath,		//	number of path points
		pWORLD	ppPath,		//	path curve points
		pWORLD	ppScale,	//	path scaling factors
		pWORLD	ppRotate,	//	path rotation factors
		pWORLD	pOut		//	Output Pts array
	)	  
{
	// Ask User Clockwise? Maximum Angle? *****
	/////////////////////////////////////////////////////
	pWORLD	pRow,pP,pS,pR;
	WORLD	dMaxScale,dMaxTwist;
	int		i,ii;
	double 	r,dLen,dAng;
	long	sizeRow;
//	Matrix	R;
	////////////////////////////////
	WORLD td,Rotated[2];
	pWORLD pRotated = Rotated;
	///////////////////////
	if(pOut)
	{
		/////////////////////// normalize Scale wrt Max
		dMaxScale.x = -DBL_MIN;
		dMaxScale.y = -DBL_MIN;
		dMaxScale.z = -DBL_MIN;
		for (i=0;i<npPath;i++)
		{
			if(dMaxScale.x<(ppRotate+i)->x)
				dMaxScale.x = (ppRotate+i)->x;
			if(dMaxScale.y<(ppRotate+i)->y)
				dMaxScale.y = (ppRotate+i)->y;
			if(dMaxScale.z<(ppRotate+i)->z)
				dMaxScale.z = (ppRotate+i)->z;
		}
		////////////////////
		if(dMaxScale.x<=0.)
			dMaxScale.x = 1.;
		if(dMaxScale.y<=0.)
			dMaxScale.y = 1.;
		if(dMaxScale.z<=0.)
			dMaxScale.z = 1.;
		///////////////////////////////////////////////				
		/////////////////////// normalize Twist wrt Max
		dMaxTwist.x = -DBL_MIN;
		dMaxTwist.y = -DBL_MIN;
		dMaxTwist.z = -DBL_MIN;
		for (i=0;i<npPath;i++)
		{
			if(dMaxTwist.x<(ppScale+i)->x)
				dMaxTwist.x = (ppScale+i)->x;
			if(dMaxTwist.y<(ppScale+i)->y)
				dMaxTwist.y = (ppScale+i)->y;
			if(dMaxTwist.z<(ppScale+i)->z)
				dMaxTwist.z = (ppScale+i)->z;
		}
		/////////////////////
		if(dMaxTwist.x<=0.)
			dMaxTwist.x = 1.;
		if(dMaxTwist.y<=0.)
			dMaxTwist.y = 1.;
		if(dMaxTwist.z<=0.)
			dMaxTwist.z = 1.;
		///////////////////// For Now Max = 45 deg
		//	This should be supplied by user
		//////////////////////////////////////////				
		sizeRow = npSect*sizeof(WORLD);
		/////////////////////////////////////////////////////
		BlockCopy( (HUGEBLK)ppSect, (HUGEBLK)pOut, sizeRow );
		/////////////////////////////////////////////////////
		for( pRow=pOut,ii=0;ii<npPath-1;ii++,pRow+=npSect ) 
		{
			/////////////////////////////////////////////////////
			pP = ppPath 	+ ii;
			///////////////////////////////// T-direction(tangent)
			td.x = (pP + 1)->x - pP->x;
			td.y = (pP + 1)->y - pP->y;
			td.z = (pP + 1)->z - pP->z;
			///////////////////////////////// unit
			dLen = sqrt(td.x*td.x +td.y*td.y +td.z*td.z);
			r = 1./dLen;
			td.x *= r;
			td.y *= r;
			td.z *= r;
			////////////////////////////////////////// Extrude
			ExtrudeCurve(dLen,&td,1,npSect,pRow,pRow);
			////////////////////////////////////////////
		}
			
		////////////////////////////////////////// translate
												// & Scale
												// & Rotate
		/////////////////////////////////////////////////////
		for( pRow=pOut,ii=0;ii<npPath;ii++,pRow+=npSect ) 
		{
			/////////////////////////////////////////////////////
			pP = ppPath 	+ ii;
			pS = ppScale	+ ii;
			pR = ppRotate	+ ii;
			///////////////////////////////// T-direction(tangent)
			if(ii !=(npPath-1) )
			{
				td.x = (pP + 1)->x - pP->x;
				td.y = (pP + 1)->y - pP->y;
				td.z = (pP + 1)->z - pP->z;
			}
			// otherwise previous one	
			///////////////////////////////// unit
			dLen = sqrt(td.x*td.x +td.y*td.y +td.z*td.z);
			r = 1./dLen;
			td.x *= r;
			td.y *= r;
			td.z *= r;
			/////////////////
			dAng = (pR->y/dMaxTwist.y)* 60.0;	//Temporary
			////////////														
			for(i = 0; i<npSect;i++)
			{
				pP = pRow+i;
				/////////////////////////// twist
				RotateCurve(&XSecMove,0.,dAng,&td,1,1,pP,pRotated);				
				pP->x = Rotated[1].x;													
				pP->y = Rotated[1].y;													
				pP->z = Rotated[1].z;													
				////////////////////// move to center by Anchor
				pP->x -= XSecMove.x;													
				pP->y -= XSecMove.y;													
				pP->z -= XSecMove.z;
				/////////////////////////// scale
				pP->x *= pS->x/dMaxScale.x;													
				pP->y *= pS->y/dMaxScale.y;													
				pP->z *= pS->z/dMaxScale.z;													
				/////////////////////////// move back
				pP->x += XSecMove.x;													
				pP->y += XSecMove.y;													
				pP->z += XSecMove.z;
				
			}
				
		}
	}			
	////////////////////////	
	return	npSect * npPath;
}
/*
int CSurface::Sweep
	(
		WORLD	XSecMove,	//	cross section Anchor point
		int		npSect,		//	number of cross section points
		pWORLD	ppSect,		//	cross section curve points
		int		npPath,		//	number of path points
		pWORLD	ppPath,		//	path curve points
		pWORLD	ppScale,	//	path scaling factors
		pWORLD	ppRotate,	//	path rotation factors
		pWORLD	pOut		//	Output Pts array
	)	  
//Return:Int	nOut		//	number of points emitted
{
	///////////////////////////////////////////////////// NOTE
	//	for now, cross-section curve is assumed to be  //
	//			Defined Always in XY plane             //
	//  later: todo:                                   //
	//		user defines in its local axis    		   //
	//		we will preprocess as follows:             //
	//			compute Normal to XSection,            //
	//      	Rotate Normal to +Z-Axis               //
	//		Then Continue doing rest of the process	   //
	/////////////////////////////////////////////////////
	pWORLD	pRow,p,pP,pS;
	WORLD	dMaxScale;
	int		ii,jj;
	long	sizeRow;
//	Matrix	R;
	////////////////////////////////
	BOOL	bDegen;
	int 	sign,i,j,k,tmp;
	double 	a[4],in[4],out[4],cross,r,sum;
	double 	td[4],nd[4],bd[4]; // Frenet Frame 
	DMAT 	NBT;
	///////////////////////
//	pOut = (pPoint3d)NewPtr(sizeof(Point3d)*nV);
	if(pOut)
	{
		/////////////////////// normalize Scale wrt Max
		dMaxScale.x = -DBL_MIN;
		dMaxScale.y = -DBL_MIN;
		dMaxScale.z = -DBL_MIN;
		for (i=0;i<npPath;i++)
		{
			if(dMaxScale.x<(ppScale+i)->x)
				dMaxScale.x = (ppScale+i)->x;
			if(dMaxScale.y<(ppScale+i)->y)
				dMaxScale.y = (ppScale+i)->y;
			if(dMaxScale.z<(ppScale+i)->z)
				dMaxScale.z = (ppScale+i)->z;
		}		
		///////////////////////////////////////////////
		if(dMaxScale.x<=0.)
			dMaxScale.x = 1.;
		if(dMaxScale.y<=0.)
			dMaxScale.y = 1.;
		if(dMaxScale.z<=0.)
			dMaxScale.z = 1.;
		///////////////////////////////////////////////				
		sizeRow = npSect*sizeof(WORLD);
		////////////////////////////////////////
		for( pRow=pOut,ii=0;ii<npPath;ii++,pRow+=npSect ) 
		{
			BlockCopy( (HUGEBLK)ppSect, (HUGEBLK)pRow, sizeRow );
			/////////////////////////////////////////////////////
			bDegen = FALSE; // NOT || to Y-Axis
			pP = ppPath + ii;
			pS = ppScale+ ii;
			///////////////////////////////// T-direction(tangent)
			if(ii == 0)
			{
				td[1] = (pP + 1)->x - pP->x;
				td[2] = (pP + 1)->y - pP->y;
				td[3] = (pP + 1)->z - pP->z;
			}
			else if (ii == npPath - 1)
			{	

				td[1] = pP->x - (pP - 1)->x;
				td[2] = pP->y - (pP - 1)->y;
				td[3] = pP->z - (pP - 1)->z;
			}
			else
			{
*/				
/* not needed
				b[1] = ((pP + 1)->x - pP->x)* .5; //average
				b[2] = ((pP + 1)->y - pP->y)* .5;
				b[3] = ((pP + 1)->z - pP->z)* .5;
                /////////////////////
				a[1] = (pP->x - (pP - 1)->x)* .5;
				a[2] = (pP->y - (pP - 1)->y)* .5;
				a[3] = (pP->z - (pP - 1)->z)* .5;
                /////////////////////
				td[1] = b[1] - a[1];
				td[2] = b[2] - a[2];
				td[3] = b[3] - a[3];
                ////////////////// 
*/                
/*
                /////////////////////
				td[1] = (pP + 1)->x - pP->x;
				td[2] = (pP + 1)->y - pP->y;
				td[3] = (pP + 1)->z - pP->z;
                ////////////////// 
    		}
			///////////////////// unit 
			r = 1./sqrt(td[1]*td[1] +td[2]*td[2] +td[3]*td[3]);
			td[1] *= r;
			td[2] *= r;
			td[3] *= r;
*/			 
/*  not needed			
			///////////////////////////////// N-direction(Curvature)
			if(ii == 0)
			{
				a[1] = pP->x - 2*((pP+1)->x) + (pP + 2)->x;
				a[2] = pP->y - 2*((pP+1)->y) + (pP + 2)->y;
				a[3] = pP->z - 2*((pP+1)->z) + (pP + 2)->z;
			}
			else if (ii == npPath - 1)
			{	

				a[1] = (pP - 2)->x - 2*((pP-1)->x) + pP->x;
				a[2] = (pP - 2)->y - 2*((pP-1)->y) + pP->y;
				a[3] = (pP - 2)->z - 2*((pP-1)->z) + pP->z;
			}
			else
			{	
                /////////////////////
				a[1] = (pP - 1)->x - 2*(pP->x) + (pP + 1)->x;
				a[2] = (pP - 1)->y - 2*(pP->y) + (pP + 1)->y;
				a[3] = (pP - 1)->z - 2*(pP->z) + (pP + 1)->z;
    		}
			/////////////////////////////// tda = td cross a
			for (i=1;i<=3;i++)
			{
				j = (i+1>3)?1:i+1;
				k = (j+1>3)?1:j+1;
				cross = 0.;
				///////////
				for(sign = 1;sign>=-1;sign -=2)
				{
					cross += sign*td[j]*a[k];
					tmp = k;
					k	= j;
					j	= tmp;
				}
				tda[i] = cross;
			}
			/////////////////////////////// tn = tda cross td
			for (i=1;i<=3;i++)
			{
				j = (i+1>3)?1:i+1;
				k = (j+1>3)?1:j+1;
				cross = 0.;
				///////////
				for(sign = 1;sign>=-1;sign -=2)
				{
					cross += sign*tda[j]*td[k];
					tmp = k;
					k	= j;
					j	= tmp;
				}
				nd[i] = cross;
			}
*/
/*
			// y-degeneracy check			
			r = td[1]*td[1] +td[3]*td[3]; //dx**2 + dz**2
			if(r) // Path not in Y-direction
			{
				///////////////////////////////// N(x)-direction(Y x T)
				a[1] = 0.;
				a[2] = 1.;
				a[3] = 0.;
				/////////////////////////////// tn = a cross td
				for (i=1;i<=3;i++)
				{
					j = (i+1>3)?1:i+1;
					k = (j+1>3)?1:j+1;
					cross = 0.;
					///////////
					for(sign = 1;sign>=-1;sign -=2)
					{
						cross += sign*a[j]*td[k];
						tmp = k;
						k	= j;
						j	= tmp;
					}
					nd[i] = cross;
				}
				///////////////////// unit 
				r = 1./sqrt(nd[1]*nd[1] +nd[2]*nd[2] +nd[3]*nd[3]);
				nd[1] *= r;
				nd[2] *= r;
				nd[3] *= r;
				///////////////////////////////// B(y)-direction(T(z) x N(x))
				for (i=1;i<=3;i++)
				{
					j = (i+1>3)?1:i+1;
					k = (j+1>3)?1:j+1;
					cross = 0.;
					///////////
					for(sign = 1;sign>=-1;sign -=2)
					{
						cross += sign*td[j]*nd[k];
						tmp = k;
						k	= j;
						j	= tmp;
					}
					bd[i] = cross;
				}
				///////////////////// unit 
				r = 1./sqrt(bd[1]*bd[1] +bd[2]*bd[2] +bd[3]*bd[3]);
				bd[1] *= r;
				bd[2] *= r;
				bd[3] *= r;
				////////////////////////////////// Make Matrix[N|B|T]
				NBT[0][0] = nd[1] * (pS->x)/dMaxScale.x; // scale
				NBT[1][0] = nd[2]; 
				NBT[2][0] = nd[3]; 
				NBT[3][0] = 0;
				////////////// 
				NBT[0][1] = bd[1]; 
				NBT[1][1] = bd[2] * (pS->y)/dMaxScale.y; 
				NBT[2][1] = bd[3]; 
				NBT[3][1] = 0; 
				////////////// 
				NBT[0][2] = td[1]; 
				NBT[1][2] = td[2]; 
				NBT[2][2] = td[3] * (pS->z)/dMaxScale.z; 
				NBT[3][2] = 0; 
				////////////// 
				NBT[0][3] = 0; 
				NBT[1][3] = 0; 
				NBT[2][3] = 0; 
				NBT[3][3] = 1;
			}
			else	// Path in Y-direction
			{
				bDegen =TRUE;
				sign = 1;
				if(td[2]>0.)    // Y:positive will become Zprime+
					sign = -1;	// so,Yprime+ is Z-;rotate about X 
			}					
			////////////////////////////////////////////
			for( p=pRow,jj=0;jj<npSect;jj++,p++ )
			{   
    			////// move XSec Pts to origin.
    			in[0] = p->x - XSecMove.x;      // XSec point
    			in[1] = p->y - XSecMove.y;
    			in[2] = 0;// put in XY plane
    			in[3] = 0;
                //////////////////////////////////// twist 
// will do later
				if(!bDegen) // path not || to Y-direction
				{
	                /////////////////////////// output [NBT][in]
	                for (i =0;i<4;i++)
	                {
	                	sum = 0.0;
	                	for(j=0;j<4;j++)
	                		sum += NBT[i][j] * in[j];
	                	out[i] = sum;
	                }
				}
				else	// path || to Y-direction
				{
					out[0] = in[0];	                
					out[1] = 0.;               
					out[2] = sign * in[1];
				}
				//////////////////////////		                
                p->x = out[0];
                p->y = out[1];
                p->z = out[2];		
				////////////////////// Translate Back
				p->x += pP->x;
				p->y += pP->y;
				p->z += pP->z;
			}
		}
	}			
	////////////////////////	
	return	npSect * npPath;
}
*/
int CSurface::Duct
	(
		WORLD	XSecMove,	//	cross section Anchor point
		int		npSect,		//	number of cross section points
		pWORLD	ppSect,		//	cross section curve points
		int		npPath,		//	number of path points
		pWORLD	ppPath,		//	path curve points
		pWORLD	ppRotate,	//	path rotation factors
		pWORLD	pOut		//	Output Pts array
	)	  
//Return:Int	nOut		//	number of points emitted
{
	///////////////////////////////////////////////////// NOTE
	//	for now, cross-section curve is assumed to be  //
	//			Defined Always in XY plane             //
	//  later: todo:                                   //
	//		user defines in its local axis    		   //
	//		we will preprocess as follows:             //
	//			compute Normal to XSection,            //
	//      	Rotate Normal to +Z-Axis               //
	//		Then Continue doing rest of the process	   //
	/////////////////////////////////////////////////////
	pWORLD	pRow,p,pP;//,pS;
//	WORLD	dMaxScale;
	int		ii,jj;
	long	sizeRow;
//	Matrix	R;
	////////////////////////////////
	BOOL	bDegen;
	int 	sign,i,j,k,tmp;
	double 	a[4],in[4],out[4],cross,r,sum;
	double 	td[4],nd[4],bd[4]; // Frenet Frame 
	DMAT 	NBT;
	///////////////////////
//	pOut = (pPoint3d)NewPtr(sizeof(Point3d)*nV);
	if(pOut)
	{
/*
		/////////////////////// normalize Scale wrt Max
		dMaxScale.x = -99999.;
		dMaxScale.y = -99999.;
		dMaxScale.z = -99999.;
		for (i=0;i<npPath;i++)
		{
			if(dMaxScale.x<(ppScale+i)->x)
				dMaxScale.x = (ppScale+i)->x;
			if(dMaxScale.y<(ppScale+i)->y)
				dMaxScale.y = (ppScale+i)->y;
			if(dMaxScale.z<(ppScale+i)->z)
				dMaxScale.z = (ppScale+i)->z;
		}
*/				
		///////////////////////////////////////////////				
		sizeRow = npSect*sizeof(WORLD);
		////////////////////////////////////////
		for( pRow=pOut,ii=0;ii<npPath;ii++,pRow+=npSect ) 
		{
			BlockCopy( (HUGEBLK)ppSect, (HUGEBLK)pRow, sizeRow );
			/////////////////////////////////////////////////////
			bDegen = FALSE; // NOT || to Y-Axis
			pP = ppPath + ii;
//			pS = ppScale+ ii;
			///////////////////////////////// T-direction(tangent)
			if(ii == 0)
			{
				td[1] = (pP + 1)->x - pP->x;
				td[2] = (pP + 1)->y - pP->y;
				td[3] = (pP + 1)->z - pP->z;
			}
			else if (ii == npPath - 1)
			{	

				td[1] = pP->x - (pP - 1)->x;
				td[2] = pP->y - (pP - 1)->y;
				td[3] = pP->z - (pP - 1)->z;
			}
			else
			{	
                /////////////////////
				td[1] = (pP + 1)->x - pP->x;
				td[2] = (pP + 1)->y - pP->y;
				td[3] = (pP + 1)->z - pP->z;
                ////////////////// 
    		}
			///////////////////// unit 
			r = 1./sqrt(td[1]*td[1] +td[2]*td[2] +td[3]*td[3]);
			td[1] *= r;
			td[2] *= r;
			td[3] *= r;
			// y-degeneracy check			
			r = td[1]*td[1] +td[3]*td[3]; //dx**2 + dz**2
			if(r) // Path not in Y-direction
			{
				///////////////////////////////// N(x)-direction(Y x T)
				a[1] = 0.;
				a[2] = 1.;
				a[3] = 0.;
				/////////////////////////////// tn = a cross td
				for (i=1;i<=3;i++)
				{
					j = (i+1>3)?1:i+1;
					k = (j+1>3)?1:j+1;
					cross = 0.;
					///////////
					for(sign = 1;sign>=-1;sign -=2)
					{
						cross += sign*a[j]*td[k];
						tmp = k;
						k	= j;
						j	= tmp;
					}
					nd[i] = cross;
				}
				///////////////////// unit 
				r = 1./sqrt(nd[1]*nd[1] +nd[2]*nd[2] +nd[3]*nd[3]);
				nd[1] *= r;
				nd[2] *= r;
				nd[3] *= r;
				///////////////////////////////// B(y)-direction(T(z) x N(x))
				for (i=1;i<=3;i++)
				{
					j = (i+1>3)?1:i+1;
					k = (j+1>3)?1:j+1;
					cross = 0.;
					///////////
					for(sign = 1;sign>=-1;sign -=2)
					{
						cross += sign*td[j]*nd[k];
						tmp = k;
						k	= j;
						j	= tmp;
					}
					bd[i] = cross;
				}
				///////////////////// unit 
				r = 1./sqrt(bd[1]*bd[1] +bd[2]*bd[2] +bd[3]*bd[3]);
				bd[1] *= r;
				bd[2] *= r;
				bd[3] *= r;
				////////////////////////////////// Make Matrix[N|B|T]
				NBT[0][0] = nd[1];// * (pS->x)/dMaxScale.x; // scale
				NBT[1][0] = nd[2]; 
				NBT[2][0] = nd[3]; 
				NBT[3][0] = 0;
				////////////// 
				NBT[0][1] = bd[1]; 
				NBT[1][1] = bd[2];// * (pS->y)/dMaxScale.y; 
				NBT[2][1] = bd[3]; 
				NBT[3][1] = 0; 
				////////////// 
				NBT[0][2] = td[1]; 
				NBT[1][2] = td[2]; 
				NBT[2][2] = td[3];// * (pS->z)/dMaxScale.z; 
				NBT[3][2] = 0; 
				////////////// 
				NBT[0][3] = 0; 
				NBT[1][3] = 0; 
				NBT[2][3] = 0; 
				NBT[3][3] = 1;
			}
			else	// Path in Y-direction
			{
				bDegen =TRUE;
				sign = 1;
				if(td[2]>0.)    // Y:positive will become Zprime+
					sign = -1;	// so,Yprime+ is Z-;rotate about X 
			}					
			////////////////////////////////////////////
			for( p=pRow,jj=0;jj<npSect;jj++,p++ )
			{   
    			////// move XSec Pts to origin.
    			in[0] = p->x - XSecMove.x;      // XSec point
    			in[1] = p->y - XSecMove.y;
    			in[2] = 0;// put in XY plane
    			in[3] = 0;
                //////////////////////////////////// twist 
// will do later
				if(!bDegen) // path not || to Y-direction
				{
	                /////////////////////////// output [NBT][in]
	                for (i =0;i<4;i++)
	                {
	                	sum = 0.0;
	                	for(j=0;j<4;j++)
	                		sum += NBT[i][j] * in[j];
	                	out[i] = sum;
	                }
				}
				else	// path || to Y-direction
				{
					out[0] = in[0];	                
					out[1] = 0.;               
					out[2] = sign * in[1];
				}
				//////////////////////////		                
                p->x = out[0];
                p->y = out[1];
                p->z = out[2];		
				////////////////////// Translate Back
				p->x += pP->x;
				p->y += pP->y;
				p->z += pP->z;
			}
		}
	}			
	////////////////////////	
	return	npSect * npPath;
}
/////////////////////////////////// end of module /////////////////




